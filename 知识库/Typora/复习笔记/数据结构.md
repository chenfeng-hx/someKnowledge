# 数据结构

参考书籍：

- 数据结构 (C语言版严蔚敏) 第2版
- 大话数据结构 by 程杰



# 基本概述

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230412095556666.png" alt="image-20230412095556666" style="zoom:67%;" />

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230412095627233.png" alt="image-20230412095627233" style="zoom:67%;" />



## 基本概念和术语

### 数据、数据元素、数据项和数据对象

**数据：**客观事物的符号表示，所有能输入到计算机中并被计算机程序处理的符号的总称。

**数据元素：**数据的基本单位，也称为元素、记录等。用于完整的描述一个对象，如一条学生记录、一个状态等。

**数据项：** 组成数据元素的、有独立含义的、不可分割的最小单位。如学号、姓名等。

**数据对象：** 性质相同的数据元素的集合，如一张学生表。只要集合内元素的性质均相同，都可称之为一个数据对象。



### 数据机构

**数据结构：** 相互之间存在一种或多种特定关系的数据元素的集合，是带“结构(数据元素之间存在的关系)”的数据元素的集合；包括逻辑结构和存储结构两个层次。

**逻辑结构：** 与数据存储无关，从逻辑关系上描述数据，可以看作是从具体问题抽象出来的数学模型。两个要素：数据元素(同上)和关系：指数据元素间的逻辑关系。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84image-20230404090530681.png" alt="image-20230404090530681" style="zoom: 67%;" />

1. 集合结构：数据元素间同属一个集合，各个数据元素是“平等”的。学生是否属于一个班，将班看做集合==（非线性结构）==

	<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230412103012905.png" alt="image-20230412103012905" style="zoom:67%;" />
2. 线性结构：数据元素之间存在一对一的关系，按照学生学号进行排列

	<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230412103046545.png" alt="image-20230412103046545" style="zoom:67%;" />
3. 树结构：数据元素之间存在一对多的关系，班长管多个组长，组长管组员==（非线性结构）==

	<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230412103101802.png" alt="image-20230412103101802" style="zoom:67%;" />
4. 图结构或网状结构：数据元素之间存在多对多的关系，任何两位同学都可以是朋友==（非线性结构）==

	<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230412103119485.png" alt="image-20230412103119485" style="zoom:67%;" />

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84image-20230404091051135.png" alt="image-20230404091051135" style="zoom:50%;" />



**存储结构：** 数据对象在计算机中的存储表示，也称为物理结构，既要求存储数据，又要存储数据元素之间的逻辑关系，数据元素在计算机中用一个结点表示，分为顺序存储结构和链式存储结构。

1. 顺序存储结构：借助元素在存储器中的相对位置来表示数据元素之间的逻辑关系，通常借助“数组”描述。==要求所有的元素依次存放在一片连续的存储空间中。==

	<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230412103153376.png" alt="image-20230412103153376" style="zoom:67%;" />

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84image-20230404091544113.png" alt="image-20230404091544113" style="zoom:50%;" />

2. 链式存储结构：无需占用一整块存储空间，结点关系表示：给每个结点附加指针字段，存放后继元素的存储地址，用“指针”描述。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84image-20230404091807383.png" alt="image-20230404091807383" style="zoom:50%;" />

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230412103224940.png" alt="image-20230412103224940" style="zoom:67%;" />



### 数据类型和抽象数据类型

**数据类型：** 是一个值的集合和定义在这个值集上的一组操作的总称。如C语言中的整型变量：值集为某个区间上的整数，定义在其上的操作是加减乘除等算数运算。

**抽象数据类型：** 指由用户定义的、表示应用问题的数学模型，以及定义在这个模型上的一组操作的总称，包括三部分：数据对象、数据对象上关系的集合、数据对象的基本操作的集合。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84image-20230404092659441.png" alt="image-20230404092659441" style="zoom:67%;" />

> 数据对象和数据关系的定义采用数学符号和自然语言描述，基本操作为函数



抽象数据类型的概念和面向对象方法的思想是一致的。抽象数据类型独立于具体实现，将数据和操作封装在一起，使得用户程序只能通过抽象数据类型定义的某些操作来访问其中的数据，从而实现了==信息隐藏==。



^算法与算法分析、时间复杂度等详见《算法分析与设计.md》^



## 总结

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230412103455333.png" alt="image-20230412103455333" style="zoom:67%;" />

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230412103518894.png" alt="image-20230412103518894" style="zoom:67%;" />



# 线性表

线性结构基本特点：除第一个元素无直接前驱，最后一个元素无直接后继外，其他每个数据元素都有一个直接前驱和直接后继。

## 基本概念

**线性表：** 由 n(n >= 0) 个数据特性相同的元素构成的有限序列。

**空表：** 线性表中元素的个数  n(n >= 0) 定义为线性表的长度， n=0 时为空表。



## 线性表的顺序表示与实现

**线性表的顺序存储表示：** 用一组地址连续的存储单元依次存储线性表的数据元素，称为**顺序表**，特点：逻辑上相邻的数据元素，物理次序也是相邻的。

存储位置满足：LOC(a~i+1~) = LOC(a~n~) + L(每个元素占用的存储单元)

还满足：LOC(a~n~) = LOC(a~1~) + (n - 1) * L

a~1~ 的存储位置通常称作线性表的起始位置或基地址

线性表的顺序存储结构是一种**随机存取**的存储结构。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84image-20230404145717618.png" alt="image-20230404145717618" style="zoom:67%;" />

**时间复杂度：**

- 顺序表的取值：O(1)：随机存取
- 顺序表按值查找算法的平均时间复杂度：O(n)，ASL（平均查找长度）
- 顺序表插入算法的平均时间复杂度：O(n)
- 顺序表删除算法的平均时间复杂度：O(n)

插入和删除：均需要移动大量的元素



## 线性表的链式表示和实现

### 单链表的定义和表示

**线性表链式存储结构：**用一组任意的存储单元存储线性表的数据元素（存储单元可以是连续的，也可以是不连续的），由于可以不连续，所以其结点包含两个域：存储数据元素信息的域称为**数据域**，存储直接后继存储位置的域称为**指针域**，存储的信息是指针或链。由于每个节点中只存储一个指针域，又称为线性链表或单链表。

头指针指示链表中第一个结点（也称首元结点），最后结点没有直接后继，所以指针为空（NULL）

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84image-20230404152440975.png" alt="image-20230404152440975" style="zoom: 67%;" />

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84image-20230404152551614.png" alt="image-20230404152551614" style="zoom:67%;" />

- **首元结点：**值链表中存储第一个数据元素 a~1~ 的结点
- **头结点：**在首元结点之前附设的一个结点，其指针域指向首元结点。
- **头指针：** 指向链表中第一个结点的指针。



**链表增加头结点的作用：**

1. **便于首元结点的处理**
	- 增加了头结点后，首元结点的地址保存在头结点（即其“前驱”结点）的指针域中，则对链表的第一个数据元素的操作与其他数据元素相同，无需进行特殊处理。
2. **便于空表和非空表的统一处理**
	- 当链表不设头结点时，假设 L 为单链表的头指针，它应该指向首元结点，则当单链表为长度n 为 0 的空表时，L指针为空**（**判定空表的条件可记为：L== NULL)。
	- 增加头结点后，无论链表是否为空，头指针都是指向头结点的非空指针。的非空单链表，头指针指向头结点。若为空表，则头结点的指针域为空（判定空表的条件可记为：L->next== NULL)



**时间复杂度分析：**

- 单链表取值算法的平均时间复杂度为O(n)。

- 单链表按值查找算法的平均时间复杂度为O(n)。

- 单链表插入算法的平均时间复杂度为O(n)，虽然只操作三个元素，但是在插入前需要先按顺序找到这三个元素的前驱结点。

- 单链表删除算法的平均时间复杂度为O(n)。

- 创建单链表：

	- 前插法：O(n)

	<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84image-20230404153907772.png" alt="image-20230404153907772" style="zoom:67%;" />

	- 后插法：O(n)

	<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84image-20230404153948347.png" alt="image-20230404153948347" style="zoom:67%;" />



### 静态链表

为没有指针的高级语言设计，由数组代替指针，来描述单链表。让数组的元素都是由两个数据域组成，data 和 cur，数组的每个下标都对应一个 data  和 cur， 数据域 data 用来存放数据，游标 cur 存放该元素的后继在数组中的下标。

把这种用数组描述的链表叫做 **静态链表**。

对数组的第一个和最后一个元素作为特殊元素处理，不存数据。通常把未被使用的数组元素称为备用链表。而数组的第一个元素，即下标为 0 的元素的 cur 存放备用链表的第一个节点的下标，数组的最后一个元素 cur 存放第一个由数组的元素的下标，相当于单链表中的头结点作用。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230412195155675.png" alt="image-20230412195155675" style="zoom: 67%;" />



<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230412195405020.png" alt="image-20230412195405020" style="zoom:67%;" />

 静态链表的插入和删除就是修改游标的过程。







### 循环链表

**循环链表：** 表中最后一个结点的指针域指向头结点，整个链表形成一个环，头尾相连的单链表。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84image-20230404154145762.png" alt="image-20230404154145762" style="zoom:67%;" />

当链表遍历时，判别当前指针p是否指向表尾结点的终止条件不同。在单链表中，判别条件为p!=NULL或p->next!=NULL,而循环单链表的判别条件为p!=L或p->next!=L。



### 双向链表

在双向链表的结点中有两个指针域，一个指向直接后继， 另一个指向直接前驱。



### 双向循环链表

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84image-20230404154544831.png" alt="image-20230404154544831" style="zoom:67%;" />





## 顺序表和链表的比较

### 空间性能的比较

1. 存储空间的分配

	- 顺序表的存储空间必须预先分配，元素个数扩充受一定限制，易造成存储空间浪费或空间溢出现象
	- 链表不需要为其预先分配空间，只要内存空间允许，链表中的元素个数就没有限制
	- 当线性表的长度变化较大，难以预估存储规模时，宜采用链表作为存储结构

2. 存储密度的大小

	- **存储密度：** 指数据元素本身所占用的存储量和整个结点结构所占用的存储量之比，存储密度越大，存储空间的利用率就越高。

	- 链表的每个结点除了设置数据域用来存储数据元素外，还要额外设置指针域，用来存储指示元素之间逻辑关系的指针，从存储密度上来讲，这是不经济的

	- 顺序表的存储密度为1， 而链表的存储密度小千1。 如果每个元素数据域占据的空间较小，则指针的结构性开销就占用了整个结点的大部分空间，这样存储密度较小

	- 当线性表的长度变化不大，易于事先确定其大小时，为了节约存储空间，宜采用顺

		序表作为存储结构



### 时间性能的比较

1. 存取元素的效率
	- 顺序表示数组实现的，随机存取结构，取值效率高
	- 链表是顺序存取结构，时间复杂度O(n)，取值效率低
	- 若线性表的主要操作是和元素位置紧密相关的这类取值操作，很少做插入或删除时，宜采用顺序表作为存储结构
2. 插入和删除操作的效率
	- 链表，在确定插入或删除的位置后，插入或删除操作无需移动数据，只需要修改指针，时间复杂度为0(1)
	- 顺序表，进行插入或删除时，平均要移动表中近一半的结点，时间复杂度为 O(n)
	- 对于频繁进行插入或删除操作的线性表，宜采用链表作为存储结构。



## 线性表的应用

**有序表：** 若线性表中的数据元素相互之间可以比较， 并且数据元素在线性表中依值非递减或非递增有序排列，则称该线性表为有序表

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84image-20230404232423657.png" alt="image-20230404232423657" style="zoom:67%;" />

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84image-20230404232437937.png" alt="image-20230404232437937" style="zoom:67%;" />





# 栈和队列

## 栈和队列的定义和特点

### 栈的定义和特点

**栈：** 限定仅在表尾进行插入或删除操作的线性表；表尾端称为**栈顶**，表头端称为**栈底**，不含元素的空表称为**空栈**；又称为**先进后出（后进先出）** 线性表。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84image-20230405094217969.png" alt="image-20230405094217969" style="zoom:67%;" />

### 队列的定义和特点

**队列：** 一种**先进先出**的线性表；只允许在表的一端进行插入，另一端删除元素。允许插入的一端称为**队尾**，允许删除的一端称为**队头**。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84image-20230405094756093.png" alt="image-20230405094756093" style="zoom:67%;" />



## 栈的表示和操作的实现

### 顺序栈的表示与实现

**顺序栈：** 利用一组地址连续的存储单元依次存放自栈底到栈顶的数据元素。

top 指向栈顶，base 指向栈底，当 top 和 base 的值相等时，表示空栈。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84image-20230405095217244.png" alt="image-20230405095217244" style="zoom:67%;" />



### 两栈共享空间

通过一个数组存储两个类型相同的栈。数组有两个端点，两个栈有两个栈底，让一个栈的栈底为数组的始端，即下标为 0 处，另一个栈为栈的末端，即下标为数组长度 n-1 处。两个栈如果增加元素，就是两端点向中间延伸。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230413120100494.png" alt="image-20230413120100494" style="zoom:67%;" />

栈1为空时，就是 top1 等于 -1 时，栈2为空时，就是 top2 等于 n 时，栈满时，两个指针之间相差1，即 top1 + 1 = top2

适用于数组长度固定时，适用于当两个栈的空间需求有相反关系时，也就是一个栈增长时另一个栈在缩短的情况。



### 链栈的表示与实现

**链栈：**是指采用链式存储结构实现的栈。通常链栈用单链表来表示。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84image-20230405095424400.png" alt="image-20230405095424400" style="zoom:67%;" />

将栈顶放在首节点，不需要头结点，空栈，即为头指针指向空，即 top = null



## 栈与递归

**递归：** 若在一个函数、过程或者数据结构定义的内部又直接（或间接）出现定义本身的应用，则称他们是递归的，或者是递归定义的。

递归函数在执行时，系统需设立一个“递归工作栈”存储每一层递归所需的信息，此工作栈是递归函数执行的辅助空间， 因此，分析递归算法的空间复杂度需要分析工作栈的大小。



中缀表达式转后缀表达式——详见参考《大话数据结构 p~109~》



## 队列的表示与实现

### 循环队列——队列的顺序表示和实现

#### 顺序队列

用一组地址连续的存储单元依次存放从队列头到队列尾的元素之外，尚需附设两个整型变最 front 和 rear分别指示队列头元素及队列尾元素的位置。

初始化创建空队列时，令 front **=** rear **=** 0 ,每当插入新的队列尾元素时，尾指针 rear增1;每当删除队列头元素时，头指针front增1。因此，在非空队列中，头指针始终指向队列头元素，而尾指针始终指向队列尾元素的下一个位置。（会造成“假溢出”现象，即还有空缺位置，但是尾指针已经移动到了最后，不能再继续插入元素）

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84image-20230405101447110.png" alt="image-20230405101447110" style="zoom:67%;" />

#### 循环队列

头、 尾指针以及队列元素之间的关系不变 ，只是在循环队列中**，**头、 尾指针 “依环状增1"的操作可用“模”运算来实现。 通过取模，头指针和尾指针就可以在顺序表空间内以头尾衔接的方式 ”循环＂移动。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84image-20230405101914481.png" alt="image-20230405101914481" style="zoom:67%;" />

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84image-20230405101932411.png" alt="image-20230405101932411" style="zoom:67%;" />

**判断队空和队满：**少用一个元素空间，队列空间为m时，有m-1个元素认为队满。

**队空的条件：** Q.front **=** Q.rear

**队满的条件：** (Q rear+ 1)% MAXQSIZE = Q.front



### 链队——队列的链式表示和实现

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84image-20230405102504874.png" alt="image-20230405102504874" style="zoom:67%;" />

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84image-20230405103743224.png" alt="image-20230405103743224" style="zoom:55%;" />





# 串、数组和广义表

## 字符串

### 定义

**串（字符串）：** 石油零个或多个字符组成的有限序列，可以是字母、数字或其他字符。串中字符的数目 n 称为串的长度。零个字符的串称为空串。串中任意个连续字符组成的子串序列称为该串的子串。

称两个串是相等的， 当且仅当这两个串的值相等。也就是说， 只有当两个串的长度相等，并且各个对应位置的字符都相等时才相等。



### 存储结构

1. 串的顺序存储：用一组地址连续的存储单元存储串值的字符序列。

2. 串的链式存储：对于插入和删除操作较为方便（当没有占满整数倍时会补上占位符号）。

	<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84image-20230405130941145.png" alt="image-20230405130941145" style="zoom:67%;" />

	

### 串的模式匹配算法

**串的模式匹配（串匹配）：** 子串的定位运算

在主串S中匹配子串T，若匹配成功返回子串中第一个字符出现的位置

#### BF算法

模式匹配不一定是从主串的第一个位置开始， 可以指定主串中查找的起始位置 pos。

1. 分别利用计数指针 i 和 j 指示主串 **S** 和模式 **T**中当前正待比较的字符位置， i 初值为pos, j初值为1。
2. 如果两个串均未比较到串尾， 即i和j均分别小千等千S和T的长度时，则循环执行以下操作：
	- S[i].ch和T[j].ch比较，若相等，则i和j分别指示串中下个位置， 继续比较后续字符；
	- 若不等，指针后退重新开始匹配， 从主串的下一个字符 (i=i-j+2) 起再重新和模式的第一个字符 (j=l) 比较。
3. 如果j> T.length, 说明模式T中的每个字符依次和主串S中的一个连续的字符序列相等，则匹配成功，返回和模式T中第一个字符相等的字符在主串S中的序号(i-T.length); 否则称匹配不成功，返回0。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84image-20230405132802295.png" alt="image-20230405132802295" style="zoom:67%;" />

两种极端情况：

1. 最好情况下，每趟不成功的匹配都发生在模式串的第一个字符与主串中相应字符的比较。最好情况下的平均时间复杂度是 **O(n** + **m)**，主串长度n，子串长度m
2. )最坏情况下， 每趟不成功的匹配都发生在模式串的最后一个字符与主串中相应字符的比较。最坏情况下的平均时间复杂度是 **O(n x m)**



#### KMP算法

此算法可以在O(n + m)的时间数量级上完成串的模式匹配操作。

改进在于：每当一趟匹配过程中出现字符比较不等时**，**不需回溯l指针，而是利用已经得到的 “部分匹配” 的结果将模式向右“滑动”尽可能远的一段距离后**，**继续进行比较**。**

~~理解：当某一位前面都匹配成功，但是这一位匹配不成功时，第一位不需要再和之前第一位和当前这位不成功之间的内容进行匹配了，所以滑过这些位置往后匹配。~~

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84image-20230405133325006.png" alt="image-20230405133325006" style="zoom:67%;" />

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84image-20230405151211158.png" alt="image-20230405151211158" style="zoom:67%;" />

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84image-20230405153601109.png" alt="image-20230405153601109" style="zoom:67%;" />

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84image-20230405153626497.png" alt="image-20230405153626497" style="zoom:67%;" />

当匹配过程中产生“失配”时，指针 i 不变，指针 j 退回到 next[j] 所指示的位置上重新进行比较，并且当指针 j 退至零时，指针i 和 j 需同时增1.即若主串的第 i 个字符和模式的第 1 个字符不等，应从主串的第 i + 1 个字符起重新进行匹配。



next[j] 的值是多少？

1. next[1] = 0
2. 若 t~k~ = t~j~ ，next[j + 1] = next[j] + 1
3.  若 t~k~ != t~j~ ，next[j + 1] = next[k] + 1  /  next[j + 1] = 1



#### 算法比较

虽然BF 算法的时间复杂度是O(nx m), 但 在一般情况下，其实际的执行时间近似于O(n + m), 因此至今仍被采用。KMP算法仅当模式与主串之间存在许多部分匹配的情况下，才显得比BF算法快得多。但是KMP算法的最大特点是指示主串的指针不需回溯，整个匹配过程中**，**对主串仅需从头至尾扫描一遍，这对处理从外设输入的庞大文件很有效，可以边读入边匹配，而无需回头重读**。**





## 数组

### 数组的类型定义

**数组：** 由类型相同的数据元素构成的有序集合，每个元素称为数组元素，每个元素受n(n>=1) 个线性关系的约束，使用下标访问，称该数组为 n 维数组。

一个n 维数组类型可以定义为其数据元素为 n-1维数组类型的一维数组类型**。**

数组是一种随机存取的结构。

矩阵：上三角矩阵、下三角矩阵、对角矩阵





## 广义表

#### 定义

**广义表（列表）：**一般记作 ==LS = (a~1~, a~2~, …,a~n~)== , 其中 LS是广义表的名称，n是长度，a~i~ 可以是单个元素，也可以是广义表，分别称为广义表 LS的原子和子表。

几种广义表的形式：

- A = () —— A 是一个空表， 其长度为零。
- B=(e) —— B 只有一个原子 e, 其长度为1**。**
- C= (a, (b, c, d)) —— C的长度为2,两个元素分别为原子 a 和子表(b,c, d)。
- A, B, C) —— D 的长度为3,3个元素都是广义表。显然，将子表的值代入后，则有      D = (()**,** (e), (a, (b, c, d)))。
-  E = (a, E) —— 这是一个递归的表， 其长度为2**。**E 相当于一个无限的广义表 E=(a, (a, …)))



结论：

1. 广义表的元素可以是子表**，**而子表的元素还可以是子表……由此，广义表是一个多层次的结构。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84image-20230405161034482.png" alt="image-20230405161034482" style="zoom:67%;" />

2. 广义表可为 其他广义表所共享，通过子表的名称来引用。
3. 广义表可以是一个递归的表，即广义表也可以是 其本身的一个子表。



#### 存储结构

##### 头尾链表的存储结构

两种节点：表结点表示广义表，原子节点表示原子，若广义表不空，一对确定的表头和表尾可唯一确定广义表。

一个表结点可由3个域组成：标志域、 指示表头 的指针域和指示表尾的指针域。而原子结点只需两个域 ：标志域和值域。其中tag是标志域 ， 值为1时表明结点是子表， 值为0时表明结点是原子。

![image-20230405161702958](http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84image-20230405161702958.png)

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84image-20230405161717853.png" alt="image-20230405161717853" style="zoom:67%;" />

特点：

1. 除空表的表头指针为空外， 对任何非空广义表， 其表头指针均指向一个表结点， 且该结点中的 hp 域指示广义表表头（或为原子结点 ，或为表结点）， tp 域指向广义表表尾（除非表尾为空， 则指针为空**， **否则必为表结点）。
2. 容易分清列表中原子和子表所在层次。 
3. 最高层的表结点个数即为广义表的长度。



##### 扩展线性链表的存储结构

无论是原子结点还是表结点均由三个域组成

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84image-20230405162158679.png" alt="image-20230405162158679" style="zoom:67%;" />

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84image-20230405162208256.png" alt="image-20230405162208256" style="zoom:67%;" />



# 树和二叉树

## 树和二叉树的定义

### 树的定义

**树：**是 n(n >= 0) 个结点的有限集，它或为空树（n=0）,或为非空树，对于非空树T：

- 有且仅有一个称之为根的结点
- 除根结点以外的其余结点可分为 m(m > 0) 个互不相交的有限集 T~1~，T~2~，…，T~m~，其中每一个集合本身又是一棵树，并且称为根的子树

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84image-20230405163619556.png" alt="image-20230405163619556" style="zoom:67%;" />

树也是一种递归的定义（在树的定义中又用到了树的定义），同时还有广义表



### 树的基本术语

以上图为例：

**结点：** 树中的一个独立单元。包含一个数据元素及若干指向其子树的分支（A、B等）。

**结点的度：**结点拥有的子树数称为结点的度。例如，A的度为 3, C的度为l, F的度为0。

**树的度：**树的度是树内各结点度的最大值。上图树的度为3。

**叶子：** 度为 0 的结点称为叶子或终端结点。结点 K 、 L 、F等都是树的叶子。

**非终端结点：**度不为 0 的结点称为非终端结点或分支结点。除根结点之外，非终端结点也称为内部结点。

**双亲和孩子：**结点的子树的根称为该结点的孩子，相应地，该结点称为孩子的双亲。例如，B的双亲为A, B的孩子有E和F。

**兄弟：**同一个双亲的孩子之间互称兄弟。例如，H 、 I 和J互为兄弟。

**祖先：**从根到该结点所经分支上的所有结点。例如， M 的祖先为A、 D 和H。

**子孙：**以某结点为根的子树中的任一结点都称为该结点的子孙。如 B 的子孙为E 、 K 、 L和F。

**层次：**结点的层次从根开始定义起，根为 第一层，根的孩子为第二层。树中任一结点的层次等千其双亲结点的层次加 1。

**堂兄弟：**双亲在同一层的结点互为堂兄弟。例如，结点 **G** 与E 、 F、 H 、 I 、 J互为堂兄弟。

**树的深度：**树中结点的最大层次称为树的深度或高度。上图树的深度为4。

**有序树和无序树：**如果将树中结点的各子树看成从左至右是有次序的（即不能互换），则称该树为有序树，否则称为无序树。在有序树中最左边的子树的根称为第一个孩子，最右边的称为最后一个孩子。

**森林：**是 m(m>=0)棵互不相交的树的集合。对树中每个结点而言，其子树的集合即为森林。由此，也可以用森林和树相互递归的定义来描述树。



### 二叉树的定义

**二叉树：**是n(n>=0)个结点所构成的集合，它或为空树(n= 0); 或为非空树，

对于非空树T:

- 有且仅有一个称之为根的结点；
- 除根结点以外的其余结点分为两个互不相交的子集T~1~和T~2~, 分别称为T的左子树和右子树，且T~1~和T~2~本身又都是二叉树。



二叉树与树的区别主要有以下两点：

1. 二叉树每个结点至多只有两棵子树（即二叉树中不存在度大于2 的结点）
2. 二叉树的子树有左右之分，其次序不能任意颠倒。

二叉树的递归定义表明二叉树或为空，或是由一个根结点加上两棵分别称为左子树和右子树的、互不相交的二叉树组成。由千这两棵子树也是二叉树，则由二叉树的定义，它们也可以是空树。由此，二叉树可以有5种基本形态。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84image-20230405170043507.png" alt="image-20230405170043507" style="zoom:67%;" />



## 二叉树的性质和存储结构

### 二叉树的性质

**性质1：**在二叉树的第 i 层上至多有2^i-1^ 个结点（i >= 1）

**性质2：**深度为K的二叉树至多有 2^k^ - 1 个结点（k >= 1）

**性质3：**对任何一棵二叉树 T，如果其终端结点数为 n~0~，度为 2 的结点数为 n~2~，则 n~0~ =   n~2~ + 1

**满二叉树：** 深度为k 且含有 2^k^ - 1 个结点的二叉树；每一层上的结点数都是最大结点数，即每一层 i 的结点数都具有最大值 2^i-1^

对满二叉树自上而下、自左向右连续编号，就有完全二叉树

**完全二叉树：** 深度为 k 的，有 n 个结点的二叉树，当且仅当其每一个结点都与深度为 k 的满二叉树中编号从 1 到 n 的结点一一对应时，称为完全二叉树。 

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84image-20230405172241563.png" alt="image-20230405172241563" style="zoom:67%;" />

完全二叉树的特点：

1. 叶子结点只可能在层次最大的两层上出现
2. 对于任一结点，若其右分支下的子孙的最大层次为 L，则其左分支下的子孙的最大层次必为 L 或 L+ 1

下面是完全二叉树的两条性质：

**性质4：** 具有 n 个结点的完全二叉树的深度为$\lfloor log_2n \rfloor$+ 1 。

**性质5：** 如果对一颗有 n 个结点的完全二叉树（深度为$\lfloor log_2n \rfloor$+ 1 ）的结点按层序编号（从第1层到$\lfloor log_2n \rfloor$+ 1层，每层从左到右 ），则对任一结点（1⩽i⩽n）有

1. 如果i = 1, 则结点 i 是二叉树的根，无双亲；如果 i> 1, 则其双亲PARENT( i )是结

	点$\lfloor i/2 \rfloor$。

2. 如果2i>n, 则结点i无左孩子（结点i为叶子结点）；否则其左孩子LCHILD(i)是结点2i

3. 如果 2i > n，则结点 i 无右孩子，否则其右孩子 RCHILD(i) 是结点 2i + 1



### 二叉树的存储结构

#### 顺序存储

- 对于完全二叉树，只要从根起按层序存储即可，依次自上而下、自左至右存储结点元素，即将完全二叉树上编号为i 的结点元素存储在如 上定义的一维数组中下标为i-1的分量中。
- 对于一般二叉树，则应将其每个结点与完全二叉树上的结点 相对照，存储在一维数组的相应分量中（以0表示不存在的结点）。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84image-20230405220859593.png" alt="image-20230405220859593" style="zoom:67%;" />

这种顺序存储结构仅适用于完全二叉树。因为， 在最坏的情况下， 一个深度为K且只有K个结点的单支树（树中不存在度为2 的结点）却需要长度为2^k^ -1 的一维数组。这造成了存储空间的极大浪费， 所以对于一般二叉树，更适合采取下面的链式存储结构。



#### 链式存储

表示二叉树的链表中的结点至少包含 3 个域：数据域和左、 右指针域，分别指向左、右子树。有时，为了便于找到结点的双亲**，**还可在结点结构中增加一个指向其双亲结点的指针域。利用这两种结点结构所得二叉树的存储结构分别称之为二叉链表和三叉链表。链表的头指针指向二叉树的根结点。容易证得，在含有 n个结点的二叉链表中有 n+1 个空链域。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84image-20230405221446283.png" alt="image-20230405221446283" style="zoom:67%;" />



## 遍历二叉树和线索二叉树

### 遍历二叉树

**遍历二叉树：**是指按某条搜索路径巡访树中每个结点，使得每个结点均被访问一次，而且仅被访问一次。遍历的实质是对二叉树进行线性化的过程，即遍历的结果是将非线性结构的树中结点排成一个线性序列（其实是使每个结点在线性序列中有且仅有一个直接前驱和直接后继）。

遍历方式：

1. 先序遍历：访问根节点——先序遍历左子树——先序遍历右子树
2. 中序遍历：中序遍历左子树——访问根节点——中序遍历右子树
3. 后序遍历：后序遍历左子树——后序遍历右子树——访问根节点

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84image-20230405223621271.png" alt="image-20230405223621271" style="zoom:67%;" />

无论是递归还是非递归遍历二叉树，因为每个结点被访问一次，则不论按哪一种次序进行遍历，对含 n 个结点的二叉树**，**其时间复杂度均为 O(n)。所需辅助空间为遍历过程中栈的最大容量，即树的深度**，**最坏情况下为n, 则空间复杂度也为 O(n)**。**

根据先序序列和中序序列、后序序列和中序序列其中一个就可以确定一个二叉树。

二叉树的深度为树中结点的最大层次， 二叉树的深度为左右子树深度的较大者加1。



### 线索二叉树

以二叉链表作为存储结构时，不能直接得到结点的前驱和后继信息，只能在遍历的时候动态获得，由于有n个结点的二叉链表中必定存在n+l个空链域，因此可以充分利用这些空链域来存放结点的前驱和后继信息**。**

若结点有左子树，则其!child域指示其左孩子，否则令lchild域指示其前驱；若结点有右子树，则其rchild域指示其右孩子，否则令rchild域指示其后继。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84image-20230405225229898.png" alt="image-20230405225229898" style="zoom:67%;" />

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84image-20230405225243826.png" alt="image-20230405225243826" style="zoom:67%;" />

以上述结点结构构成的二叉链表作为二叉树的存储结构，叫做**线索链表**，其中指向结点前驱和后继的指针，叫做**线索**。加上线索的二叉树称之为**线索二叉树**。对二叉树以某种次序遍历使其变为线索二叉树的过程叫做**线索化**。

实线为指针（指向左、 右子树），虚线为线索（指向前驱和后继）。在二叉树的线索链表上也添加一个头结点，并令其 lchild 域的指针指向二叉树的根结点，其 rchild 域的指针指向中序遍历时访问的最后一个结点；同时，令二叉树中序序列中第一个结点的 lchild 域指针和最后一个结点rchild 域的指针均指向头结点。这好比为二叉树建立了一个双向线索链表，既可从第一个结点起顺后继进行遍历，也可从最后一个结点起顺前驱进行遠历。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84image-20230405225815552.png" alt="image-20230405225815552" style="zoom:67%;" />

> 先序线索二叉树、中序线索二叉树、后序线索二叉树





## 数和森林

### 树的存储结构

1. **双亲表示法：**以一组连续的存储单元存储树的结点**，**每个结点除了数据域data外，还附设一个parent域用以指示其双亲结点的位置（利用每个结点只有一个双亲，求双亲和根方便，但是求节点的孩子需要遍历整个结构）。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84image-20230405230534066.png" alt="image-20230405230534066" style="zoom:67%;" />

2. **孩子表示法：**把每个结点的孩子结点排列起来，看成是一个线性表，且以单链表做存储结构，则n个结点有n个孩子链表（叶子的孩子链表为空表）。而n个头指针又组成一个线性表，为了便于查找**，**可采用顺序存储结构（便于对孩子的操作，将双亲和孩子表示法结合在一起）。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84image-20230405231056287.png" alt="image-20230405231056287" style="zoom:67%;" />

3. **孩子兄弟法（二叉树表示法、二叉链表表示法）：**即以二叉链表做树的存储结构。链表中结点的两个链域分别指向该结点的第一个孩子结点和下一个兄弟结点，分别命名为 firstchild 域和nextsibling域（可以实现各种树的操作，使用较为普遍）。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84image-20230405231241871.png" alt="image-20230405231241871" style="zoom:67%;" />

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84image-20230405231350729.png" alt="image-20230405231350729" style="zoom:67%;" />



### 森林和二叉树的转换

从树的二叉链表表示的定义可知，任何一棵和树对应的二叉树，其根结点的右子树必空。若把森林中第二棵树的根结点看成是第一棵树的根结点的兄弟，则同样可导出森林和二叉树的对应关系。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84image-20230406101443758.png" alt="image-20230406101443758" style="zoom:67%;" />

上述关系说明树和森林可以相互转换：

1. **森林转换成二叉树**：如果F={T~1~,T~2~,…，T~m~｝是森林，则可按如下规则转换成一棵二叉树B= (root, LB, RB)
	- 若 F 为空，即 m = 0，则 B 为空树
	- 若 F 非空，即 m != 0，则 B 的根 root 即为森林中第一棵树的根 ROOT(T~1~)，B 的左子树 LB 是从 T~1~ 中根结点的子树森林 F~1~ = {T~11~,T~12~,…，T~1m~} 转换而成的二叉树，右子树 RB 是从森林 F={T~2~,T~3~,…，T~m~｝ 转换而成的二叉树。
2. **二叉树转换成森林**：如果 B= (root, LB, RB) 是一颗二叉树，则可按如下规则转换成森林 F={T~1~,T~2~,…，T~m~｝
	- 若 B 为空，则 F 为空
	- 若 B 非空，则 F 中第一棵树 T~1~ 的根 ROOT(T~1~) 即为二叉树 B 的根 root，T~1~ 中根结点的子树森林 F~1~ 是由 B 的左子树 LB 转换而成的森林，F 中除 T~1~ 之外其余树组成的森林  F’={T~2~,T~3~,…，T~m~｝是由 B 的右子树 RB 转换而成的森林



### 树和森林的遍历

1. **树的遍历（对于上图5.19）**
	1. 先根遍历：先访问树的根结点，然后依次先根遍历根的每棵子树：RADEBCFGHK
	2. 后根遍历：先依次后根遍历每棵子树，然后访问树的根结点：DEABGHKFCR
2. **森林的遍历（若森林非空，对于上图5.24）**
	1. 先序遍历森林
		1. 访问森林中第一棵树的根结点
		2. 先序遍历第一棵树的根结点的子树森林
		3. 先序遍历除去第一棵树之后剩余的树构成的森林
		4. ABCDEFGHIJ
	2. 中序遍历森林
		1. 中序遍历森林中第一棵树的根结点的子树森林
		2. 访问第一棵树的根结点
		3. 中序遍历除去第一棵树之后剩余的树构成的森林
		4. BCDAFEHJIG



## 哈夫曼树及其应用

### 基本概念

**哈夫曼树（最优树）：**是一类带权路径长度最短的树

**路径：**从树中一个结点到另一个结点之间的分支构成这两个结点之间的路径。

**路径长度：**路径上的分支数目称作路径长度

**树的路径长度：**从树根到每一结点的路径长度之和

**权：**赋予某个实体的一个量，是对实体的某个或某些属性的数值化描述。 

**结点的带权路径长度：**从该结点到树根之间的路径长度与结点上权的乘积。

**树的带权路径长度：**树中所有叶子结点的带权路径长度之和，通常记作WPL= $\sum ^n\limits_{k=1} w_kl_k$。

**哈夫曼树：**假设有m个权值{w~1~, w~2~, …，w~m~｝，可以构造一棵含n个叶子结点的二叉树，每个叶子结点的权为 w~i~ , 则 其中带权路径长度 WPL最小的二叉树称做最优二叉树或哈夫曼树。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230406110222922.png" alt="image-20230406110222922" style="zoom:67%;" />

从上面例子中可以看到，在哈夫曼树中，权值越大的结点离根结点越近。根据这个特点，哈夫曼最早给出了一个构造哈夫曼树的方法，称哈夫曼算法 。



### 哈夫曼树的构造算法

**构造过程**

1. 根据给定的n个权值｛w~1~，w~2~ ,…，w~n~｝，构造n棵只有根结点的二叉树，这n棵二叉树构成一个森林F。
2. 在森林 F 中选取两棵根结点的权值最小的树作为左右子树构造一棵新的二叉树，且置新的二叉树的根结点的权值为其左 、右子树上根结点的权值之和。
3. 在森林 F 中删除这两棵树，同时将新得到的二叉树加入到 F 中。
4. 重复步骤2、3，直到 F 只含一棵树为止。这棵树便是哈夫曼树。
5. 这种构造法中，首先选择权小的，这样保证权大的离根较近，这样在计算树的带权路径长度是就会得到最小的路径长度，是一种典型的**贪心法**。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230406111135250.png" alt="image-20230406111135250" style="zoom:67%;" />

**哈夫曼算法的实现**

由千哈夫曼树中没有度为 1 的结点，则一棵有 n 个叶子结点的哈夫曼树共有 2n-I 个结点，可以存储在一个大小为 2n-I的一维数组中。树中每个结点还要包含其双亲信息和孩子结点的信息。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230406111404676.png" alt="image-20230406111404676" style="zoom:67%;" />



### 哈夫曼编码

**前缀编码：**如果在一个编码方案中，任何一个编码都不是其他任何编码的前缀（最左子串），则称编码是前缀编码。0、10、110 是前缀编码，但 0、01、010不是。前缀编码可以保证对压缩文件进行解码时不产生二义性， 确保正确解码。

**哈夫曼编码：**对一棵具有n个叶子的哈夫曼树，若对树中的每个左分支 赋予**0,** 右分支赋予1，则从根到每个叶子的路径上，各分支 的赋值分别构成一个二进制串， 该二进制串就称为哈夫曼编码。

两条性质：

1. 哈夫曼编码是前缀编码（哈夫曼编码对应路径的终点一定为叶子）
2. 哈夫曼编码是最优前缀编码：对于包括n个字符的数据文件，分别以它们的出现次数为权值构造哈夫曼树，则利用该树对应的哈夫曼编码对文件进行编码， 能使该文件压缩后对应的二进制文件的长度最短。

求哈夫曼编码的主要思想是：依次以叶子为出发点，向上回溯至根结点为止。回溯时走左分支则生成代码0，走右分支则生成代码1。







# 图

## 图的定义和基本术语

### 图的定义

**图：**G由两个集合V和E组成，记为G=(V,E) , 其中V是顶点的有穷非空集合，E是V中顶点偶对的有穷集合，这些顶点偶对称为边。V(G)和E(G)通常分别表示图G的顶点集合和边集合，E(G**)**可以为空集。若E(G)为空，则图G只有顶点而没有边。

- 若边集E(G)为有向边的集合，则称该图为有向图
- 若边集E(G)为无向边的集合，则称该图为无向图

在有向图中，顶点对<x, y>是有序的，它称为从顶点 x到顶点 y的一条有向边。 因此<x,y> 与 <y, x> 是不同的两条边。顶点对用一对尖括号括起来，x 是有向边的始点，y 是有向边的终点。<x, y> 也称做一条弧，则 x 为弧尾，y 为弧头。

在无向图中，顶点对(x, y) 是无序的，它称为与顶点 x 和顶点 y 相关联的一条边。这条边没有特定的方向，(x, y)与 （y, x）是同一条边，为了区别有向图，无向图顶点用圆括号括起来。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230406133327877.png" alt="image-20230406133327877" style="zoom:67%;" />



### 图的基本术语

**子图：**假设有两个图 G = (V, E)和 G'= (V', E'), 如果$V'\subseteq V$且 $E'\subseteq E$, 则称 G'为 G 的子图。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230406133727203.png" alt="image-20230406133727203" style="zoom: 67%;" />

**无向完全图和有向完全图：**对千无向图，若具有 n(n - 1)/2 条边，则称为**无向完全图**。对于有向图，若具有 n(n- l) 条弧，则称为**有向完全图**。

**稀疏图和稠密图：**有很少条边或弧（如 e < nlog~2~^n^ ) 的图称为稀疏图， 反之称为稠密图。

**权和网：**在实际应用中，每条边可以标上具有某种含义的数值，该数值称为该边上的权。这些权可以表示从一个顶点到另一个顶点的距离或耗费。这种带权的图通常称为网。

**邻接点：**对于无向图 G, 如果图的边 (v, v')$\in$E, 则称顶点 v 和 v'互为邻接点， 即 v 和 v'相邻接。边 (v, v')依附于顶点 v 和 v',  或者说边 (v, v')与顶点 v 和 v'相关联。

**度：**顶点 v 的度是指和 v 相关联的边的数目（该点和几条边相连度就是多少），记为 TD(v)。

**入度和出度：**对于有向图，顶点v的度分为入度和出度。入度是以顶点v为头的弧（边）的数目，记为ID(v); 出度是以顶点 v 为尾的弧（边）的数目，记为OD(v)，点 v 的度为 TD(v) **=** ID(v) + OD(v)。一般地，如果顶点 v~i~ 的度记为 TD(v~i~)，那么一个有n个顶点，e条边的图，满足如下关系：$e = \frac{1}{2}\sum \limits^n _{i=1}TD(v_i)$

**路径和路径长度：**在无线图 G 中，从顶点 v 到顶点 v’ 的路径是一个顶点序列(v = v~i,0~ , v~i,1~, …, v~i,m~ = v’)，其中( v~i,j-1~， v~i,j~ ) $\in$ E，1$\leq$ j $\leq$ m；如果 G 是有向图，则路径也是有向的，顶点序列应满足 <v~i,j-1~, v~i,j~> $\in$ E，1$\leq$ j $\leq$ m；路径长度是一条路径上经过的边或弧的数目。

**回路或环：**第一个顶点和最后一个顶点相同的路径称为回路或环。

**简单路径、 简单回路或简单环：**序列中顶点不重复出现的路径称为简单路径。除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为简单回路或简单环。

**连通、连通图和连通分量：**在无向图 G 中，如果从顶点 v 到顶点 v'有路径，则称 v 和 v' 是连通的。如果对于图中任意两个顶点 v~i~、v~j~ $\in$ V, v~i~ 和 v~j~都是连通的，则称 G 是连通图。上面图 6.1(b) 就是一个连通图。下图 G~3~ 就是非连通图，但是有3个连通分量，如图(b) 。所谓连通分量， 指的是无向图中的极大连通子图。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230406140447325.png" alt="image-20230406140447325" style="zoom:67%;" />

**强连通图和强连通分量：**在有向图 G 中，如果对于每一对  v~i~、v~j~ $\in$ V,v~i~ $\neq$ v~j~ , 从 v~i~到 v~j~ 和从v~j~到 v~i~ 都存在路径，则称G是强连通图。有向图中的极大强连通子图称作有向图的强连通分量。下图中的G~1~,不是强连通图，但它有两个强连通分量。

强连通图只有一个强连通分量，即是其自身。非强连通的有向图有多个[强连通分量](https://baike.baidu.com/item/强连通分量?fromModule=lemma_inlink)

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230406140925731.png" alt="image-20230406140925731" style="zoom:67%;" />

[极大连通图和极小连通图](http://t.csdn.cn/igfm7)

**连通图的生成树：** 一个极小连通子图，它含有图中全部顶点，但只有足以构成一棵树的 n-1条边，这样的连通子图称为连通图的生成树。下图为G~3~中最大连通分量的一棵生成树。如果在一棵生成树上添加一条边，必定构成一个环，因为这条边使得它依附的那两个顶点之间有了第二条路径。

一棵有n个顶点的生成树有且仅有n-1条边。如果一个图有 n 个顶点和小于 n - l 条边，则是非连通图。如果它多于 n -1 条边，则一定有环。但是，有 n - 1条边的图不一定是生成树。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230406144007986.png" alt="image-20230406144007986" style="zoom:67%;" />

**有向树和生成森林：**有一个顶点的入度为 0, 其余顶点的入度均为 1 的有向图称为有向树。 一个有向图的生成森林是由若干棵有向树组成，含有图中全部顶点，但只有足以构成若干棵不相交的有向树的弧。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230406144112978.png" alt="image-20230406144112978" style="zoom:67%;" />



## 图的存储结构

### 邻接矩阵

##### 邻接矩阵表示法

**邻接矩阵：**表示顶点之间相邻关系的矩阵。设G(V, E)是具有n个顶点的图，则G的邻接矩阵是具有如下性质的n阶方阵

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230406154454480.png" alt="image-20230406154454480" style="zoom:67%;" />

图6.1所示的G1和 G2 的邻接矩阵：

![image-20230406154541882](http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230406154541882.png)

若 G 是网，则邻接矩阵则定义为：

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230406154748994.png" alt="image-20230406154748994" style="zoom:67%;" />

W~i，j~ 表示边上的权值； ∞ 表示计算机允许的、 大于所有边上权值的数

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230406155143387.png" alt="image-20230406155143387" style="zoom:80%;" />

**优缺点：**

- 优点：
	- 便于判断两个顶点之间是否有边， 即根据A\[i]\[j] = 0或1来判断。
	- 便于计算各个顶点的度。对千无向图，邻接矩阵第 i 行元素之和就是顶点 i 的度；对于有向图，第 i 行元素之和就是顶点 i 的出度，第 i 列元素之和就是顶点 i  的入度。
- 缺点：
	- 不便于增加和删除顶点。
	- 不便于统计边的数目，需要扫描邻接矩阵所有元素才能统计完毕，时间复杂度为O(n^2^)。
	- 空间复杂度高。如果是有向图，n个顶点需要 n^2^ 个单元存储边。如果是无向图，因其邻接矩阵是对称的**，**所以对规模较大的邻接矩阵可以采用压缩存储的方法，仅存储下三角（或上三角）的元素，这样需要n(n-1)/2个单元即可**。**但无论以何种方式存储**，**邻接矩阵表示法的空间复杂度均为0(n^2^)，这对于稀疏图而言尤其浪费空间。



### 邻接表

##### 邻接表表示法

**邻接表：**将邻接矩阵的 n行改成n个单链表，适合表示稀疏图。对图中每个顶点v~i~ 建立一个单链表，把与 v~i~ 相邻接的顶点放在这个链表中**。**邻接表中每个单链表的第一个结点存放有关顶点的信息， 把这一结点看成链表的表头， 其余结点存放有关边的信息， 这样邻接表便由两部分组成：表头结点表和边表。

1. **表头结点表：**由所有表头结点以顺序结构的形式存储， 以便可以随机访问任一顶点的边链表。表头结点包括数据域 (data) 和链域 (firstarc) 两部分。数据域用于存储顶点 V~i~ 的名称或其他有关信息；链域用于指向链表中第一个结点（即与顶点 V~i~ 邻接的第一个邻接点）。
2. **边表：**由表示图中顶点间关系的 2n个边链表组成。 边链表中边结点包括邻接点域(adjvex)、数据域 (info) 和链域 (nextarc) 三部分。其中， 邻接点域指示与顶点 V~i~ 邻接的点在图中的位置；数据域存储和边相关的信息， 如权值等；链域指示与顶点v~i~邻接的下一条边的结点。 

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230406161025472.png" alt="image-20230406161025472" style="zoom:67%;" />



下图(a) 和(b)所示分别为图6.1中G~1~, 和G~2~的邻接表。在无向图的邻接表中，顶点 V~i~ 的度恰为第i个链表中的结点数；而在有向图中， 第 i 个链表中的结点个数只是顶点 V~i~ 的出度， 为求入度，必须遍历整个邻接表。在所有链表中， 其邻接点域的值为 i 的结点的个数是顶点 V~i~ 的入度。有时， 为了便于确定顶点的入度， 可以建立一个有向图的逆邻接表， 即对每个顶点v建立一个链接所有进入V~i~ 的边的表，例如，(C)所示为有向图G~1~ 的逆邻接表。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230406161938171.png" alt="image-20230406161938171" style="zoom:80%;" />



**优缺点：**

- 优点：
	- 便千增加和删除顶点。
	- 便千统计边的数目， 按顶点表顺序扫描所有边表可得到边的数目，时间复杂度为O(n + e)
	- 空间效率高。对于一个具有n个顶点e条边的图 G, 若 G 是无向图，则在其邻接表表示中有 n 个顶点表结点和 2e 个边表结点；若 G 是有向图，则在它的邻接表表示或逆邻接表表示中均有 n 个顶点表结点和e个边表结点。因此，邻接表或逆邻接表表示的空间复杂度为O(n + e),适合表示稀疏图。对于稠密图，考虑到邻接表中要附加链域，因此常采取邻接矩阵表示法。
- 缺点：
	- 不便于判断顶点之间是否有边，要判定 V~i~ 和V~j~ 之间是否有边，就需扫描第i个边表，最坏情况下要耗费 O(n)时间。
	- 不便于计算有向图各个顶点的度。对于无向图，在邻接表表示中顶点V~i~ 的度是第i个边表中的结点个数。 在有向图的邻接表中，第 i 个边表上的结点个数是顶点 V~i~ 的出度，但求 V~i~ 的入度较困难，需遍历各顶点的边表。若有向图采用逆邻接表表示，则与邻接表表示相反，求顶点的入度容易，而求顶点的出度较难。



### 十字链表

**十字链表：**，有向图的另一种链式存储结构，便于求得顶点的入度和出度。可以看成是将有向图的邻接表和逆邻接表结合起来得到的一种链表。 在十字链表中，对应于有向图中每一条弧有一个结点，对应于每个顶点也有一个结点。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230406170720967.png" alt="image-20230406170720967" style="zoom:67%;" />

在弧结点中有 5 个域：其中尾域 (tailvex) 和头域 **(**headvex**)** 分别指示弧尾和弧头这两个顶点在图中的位置，链域 hlink 指向弧头相同的下一条弧，而链域 tlink 指向弧尾相同的下一条弧，info域指向该弧的相关信息。弧头相同的弧在同一链表上，弧尾相同的弧也在同一链表上。它们的头结点即为顶点结点，它由3个域组成：其中 data 域存储和顶点相关的信息，如顶点的名称等；firstin和 firstout为两个链域，分别指向以该顶点为弧头或弧尾的第一个弧结点。



下图：若将有向图的邻接矩阵看成是稀疏矩阵的话，则十字链表也可以看成是邻接矩阵的链表存储结构，在图的十字链表中，弧结点所在的链表非循环链表，结点之间相对位置自然形成，不一定按顶点序号有序，表头结点即顶点结点，它们之间不是链接，而是顺序存储。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230406171024331.png" alt="image-20230406171024331" style="zoom:67%;" />



### 邻接多重表

**邻接多重表：**无向图的另一种链式存储结构，在这种表中，每一条边用一个结点表示，由6个域组成。mark 为标志域，可用以标记该条边是否被搜索过； ivex 和 jvex为该边依附的两个顶点在图中的位置； ilink 指向下一条依附于顶点 ivex 的边； jlink 指向下一条依附于顶点jvex的边，info为指向和边相关的各种信息的指针域。每一个顶点也用一个结点表示，它由两个域组成。其中， data域存储和该顶点相关的信息，firstedge域指示第一条依附于该顶点的边。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230406171624030.png" alt="image-20230406171624030" style="zoom:67%;" />

在邻接多重表中，所有依附于同一顶点的边串联在同一链表中，由于每条边依附于两个顶点，则每个边结点同时链接在两个链表中。可见，对无向图而言，其邻接多重表和邻接表的差别，仅仅在于同一条边在邻接表中用两个结点表示，而在邻接多重表中只有一个结点。因此，除了在边结点中增加一个标志域外，邻接多重表所需的存储量和邻接表相同。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230406171740732.png" alt="image-20230406171740732" style="zoom:67%;" />



## 图的遍历

从图中的某一顶点出发，按照某种方法对图中所有顶点访问且仅访问一次。为了避免同一顶点被访问多次， 在遍历图的过程中， 必须记下每个已访问过的顶点。

按照搜索路径的方向，分为两条遍历图的路径：深度优先和广度优先



### 深度优先搜索

是树的先序遍历的推广。

对于一个连通图，深度优先搜索遍历的过程如下：

1. 从图中某个顶点v出发， 访问v。

2. 找出刚访问过的顶点的第一个未被访问的邻接点， 访问该顶点。 以该顶点为新顶点，重复此步骤， 直至刚访问过的顶点没有未被访问的邻接点为止。

3. 返回前一个访问过的且仍有未被访问的邻接点的顶点，找出该顶点的下一个未被访问的邻接点， 访问该顶点。

4. 重复步骤 (2) 和(3), 直至图中所有顶点都被访问过，搜索结束。
5. 下图：V~1~-V~2~-V~4~-V~8~-V~5~-V~3~-V~6~-V~7~ 

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230406172341941.png" alt="image-20230406172341941" style="zoom:67%;" />

(b) 中所示的所有顶点加上标有实箭头的边， 构成一棵以 V~1~为根的树，称为**深度优先生成树**。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230406172633981.png" alt="image-20230406172633981" style="zoom:67%;" />

**算法分析**

遍历图的过程实质上是对每个顶点查找其邻接点的过程，其耗费的时间则取决于所采用的存储结构。 当用邻接矩阵表示图时，查找每个顶点的邻接点的时间复杂度为 O(n^2^), 其中n为图中顶点数**。**而当以邻接表做图的存储结构时**，**查找邻接点的时间复杂度为O(e), 其中e为图中边数。由此，当以邻接表做存储结构时，深度优先搜索遍历图的时间复杂度为 O(n + e)。





### 广度优先搜索

类似于树的按层次遍历的过程，从左到右，从上到下。

广度优先搜索遍历的过程如下：

1. 从图中某个顶点v出发，访问v。
2. 依次访问v的各个未曾访问过的邻接点。
3. 分别从这些邻接点出发依次访问它们的邻接点，并使 “先被访问的顶点的邻接点” 先于“后被访问的顶点的邻接点” 被访问。重复步骤(3), 直至图中所有已被访问的顶点的邻接点都被访间到。
4. 对上图G~4~：V~1~-V~2~-V~3~-V~4~-V~5~-V~6~-V~7~-V~8~
5. 图6.18 (b)中所示的所有顶点加上标有实箭头的边， 构成一棵以w为根的树， 称为**广度优先生成树**。

尽可能先对横向进行搜索。设 x 和y是两个相继被访间过的顶点，若当前是以x为出发点进行搜索，则在访问x的所有未曾被访问过的邻接点之后，紧接着是以y为出发点进行横向搜索，并对搜索到的y的邻接点中尚未被访问的顶点进行访问。也就是说，先访问的顶点其邻接点亦先被访问。为此，算法实现时需引进队列保存已被访问过的顶点。

时间复杂度和深度搜索相同，两者仅仅是对顶点的访问顺序不同。



## 图的应用

### 最小生成树

在一个连通网的所有生成树中，各边的代价之和最小的那棵生成树称为该连通网的**最小代价生成树**, 简称为**最小生成树**。

**最小生成树的MST性质：**假设 N= (V, E)是一个连通网，**U**是顶点集 V的一个非空子集。若(u, v)是一条具有最小权值（代价）的边，其中u$\in$U, v$\in$V-U, 则必存在一棵包含边(u, v)的最小生成树(多数最小生成树构造算法都利用了这条性质)。



#### 普里姆算法

构造过程——假设 N=(V,E)是连通网， TE是 N 上最小生成树中边的集合：

1. U = { u~0~ }( u~0~ $\in$ V )， TE = { }
2. 在所有 u $\in$ U, v $\in$ V-U 的边 (u,v) $\in$ E 中找一条权值最小的边(uo,vo)并入集合 TE, 同时 v~0~并入U
3. 重复上一步，直到 U=V 为止
4. 此时 TE 中必有 n-1 条边， 则 T= (V, TE)为 N的最小生成树。
5. 在下面的例子中看到该算法逐步增加 U 中的顶点，可称为“加点法”

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230406181212272.png" alt="image-20230406181212272" style="zoom:80%;" />

**理解：一直找出最小边（从小到大）直到变成一个连通图（对于权相同的边任选即可）。**

普里姆算法的时间复杂度为 O(n^2^), 与网中的边数无关，因此适用千求稠密网的最小生成树。



#### 克鲁斯卡尔算法

构造过程——假设连通网N=(V,E), 将N中的边按权值从小到大的顺序排列：

1. 初始状态为只有n个顶点而无边的非连通图 T= (V, {}), 图中每个顶点自成一个连通分量。
2. 在E中选择权值最小的边， 若该边依附的顶点落在T中不同的连通分量上 （即不形成回路），则将此边加入到T中，否则舍去此边而选择下一条权值最小的边。
3. 重复上一步，直至T中所有顶点都在同一连通分量上为止。
4. 下图为针对上图中 G~5~ 的克鲁斯卡尔算法实现。
5. 克鲁斯卡尔算法逐步增加生成树的边，与普里姆算法相比，可称为“加边法”

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230407165630740.png" alt="image-20230407165630740" style="zoom: 80%;" />

克鲁斯卡尔算法的时间复杂度为 O(elog~2~^e^），与网中的边数有关，与普里姆算法相比，克鲁斯卡尔算法更适合求稀疏网的最小生成树。





### 最短路径

在带权有向网中，习惯上称路径上的第一个顶点为源点，最后一个顶点为终点。

**求从某个源点到其余各顶点的最短路径**：给定带权有向图G和源点Vo , 求从Vo到G中其余各顶点的最短路径。

#### 迪杰斯特拉算法

按路径长度递增的次序产生最短路径

**算法过程：**

对于网 N=(V,E), 将 N中的顶点分成两组：

第一 组S: 已求出的最短路径的终点集合（初始时只包含源点Vo)。

第二组 V-S: 尚未求出的最短路径的顶点集合（初始时为 V- {vo})。

算法将按各顶点与Vo间最短路径长度递增的次序，逐个将集合 v-s 中的顶点加入到集合S中去。在这个过程中，总保持从Vo到集合S中各顶点的路径长度始终不大于到集合 v-s 中各顶点的路径长度。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230407171456275.png" alt="image-20230407171456275" style="zoom:67%;" />

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230407171506104.png" alt="image-20230407171506104" style="zoom: 67%;" />

时间复杂度为O(n^2^)

------

**求每一对顶点之间的最短路径：**两种方法：其一是分别以图中的每个顶点为源点共调用n次迪杰斯特拉算法；其二是采用弗洛伊德算法。 两种算法的时间复杂度均为O(n^3^), 但后者形式上较简单。

#### 弗洛伊德算法

算法步骤：将 V~i~ 到 V~j~ 的最短路径长度初始化， 即D[i]\[j] **=** Garcs[i]\[j]，然后进行n次比较和更新。

1. 在V~i~ 和 V~j~ 间加入顶点 V~0~，比较 (V~i~, V~j~) 和 (V~i~, V~0~,  V~j~) 的路径长度，取其中较短者作为V~i~ 到 V~j~  的中间顶点序号不大于 0 的最短路径。
2. 在V~i~和 V~j~ 间加入顶点V~1~，得到  (V~i~, …, V~1~) 和  (V~1~, …, V~j~)， 其中(V~i~, …, V~1~) 是 V~i~ 到 V~1~ 的且中间顶点的序号不大于 0 的最短路径， (V~1~, …, V~j~) 是 V~1~ 到 V~j~ 的且中间顶点的序号不大于 0 的最短路径，这两条路径已在上一步中求出。 比较 (V~i~, …, V~1~, … ,  V~j~)与上一步求出的V~i~ 到 V~j~  的中间顶点序号不大于 0 的最短路径，取其中较短者作为V~i~ 到 V~j~ 的中间顶点序号不大于 1 的最短路径。
3. 依次类推，在V~i~ 和 V~j~间加入顶点V~k~, 若 (V~i~, …, V~k~) 和 (V~k~, … , V~j~) 分别是从 V~i~ 到 V~k~ 和从V~k~ 到 V~j~ 的中间顶点的序号不大于 K - 1的最短路径， 则将(V~i~, …, V~k~, … ,  V~j~)和已经得到的从 Vi 到 V~j~ 且中间顶点序号不大于 k-l 的最短路径相比较， 其长度较短者便是从V~i~ 和 V~j~  的中间顶点的序号不大于K的最短路径。这样，经过n次比较后， 最后求得的必是从 V~i~ 到 V~j~ 的最短路径。按此方法，可以同时求得各对顶点间的最短路径。

通过上述求解过程，图中所有顶点对 V~i~ 和 V~j~ 间的最短路径长度对应一个 n 阶方针 D。在上述 n+1 步中，D的值不断变化，对应一个 n 阶方阵序列。

n 阶方阵序列可定义为：D^(-1)^, D^(0)^,  D^(1)^,  … , D^(k)^, … , D^(n-1)^,  其中：

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230407175014363.png" alt="image-20230407175014363" style="zoom:67%;" />





### 拓扑排序

解决有优先级内容的问题：如学生必须先学了第一门课后才能继续学习第二门课。

**DAG 图：**一个无环的有向图称作有向无环图。

这种用顶点表示活动，用弧表示活动间的优先关系的有向图称为顶点表示活动的网，简称 **AOV-网**。在网中，若从顶点 V~i~ 到 顶点 V~j~ 有一条有向路径， 则 V~i~ 是 V~j~ 的前驱； V~j~ 是V~i~ 的后继。若<V~i~，V~j~> 网中一条弧，则 V~i~ 是 V~j~ 的直接前驱，V~j~ 是 V~i~ 的直接后继。

在AOV-网中，不应该出现有向环，因为存在环意味着某项活动应以自己为先决条件。显然， 这是荒谬的。

对给定的 AOV-网应首先判定网中是否存在环。检测的办法是对有向图的顶点进行拓扑排序，若网中所有顶点都在它的拓扑有序序列中， 则该AOV-网中必定不存在环。

**拓扑排序：**将 AOV-网 中所有的顶点排成一个线性序列，该序列满足：若在 AOV-网 中由顶点 v~i~ 到顶点 v~j~ 有一条路径，则在该线性序列中的顶点 v~i~ 必定在定点 v~j~ 之前。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230408140506724.png" alt="image-20230408140506724" style="zoom:67%;" />

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230408140533984.png" alt="image-20230408140533984" style="zoom: 67%;" />

**拓扑排序的过程：**

1. 在有向图中选一个无前驱的顶点且输出它。
2. 从图中删除该顶点和所有以它为尾的弧。
3. 重复步骤1、2直到不存在无前驱的顶点。
4. 若此时输出的顶点数小于有向图中的顶点数，则说明有向图中存在环，否则输出的顶点序列即为一个拓扑序列。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230408141044874.png" alt="image-20230408141044874" style="zoom:67%;" />





### 关键路径

**AOE-网：**即以边表示活动的网。是一个带权的有向无环图，顶点表示事件，弧表示活动，权表示活动持续的时间。通常用来估算工程的完成时间。

下图表示一个有9个事件，11个活动的AOE-网。每个事件表示在它之前的活动已经完成，在它之后的活动可以开始。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230408142046701.png" alt="image-20230408142046701" style="zoom:67%;" />

由于整个工程只有一个开始点和一个完成点，故在正常的情况（无环）下， 网中只有一个入度为零的点， 称作源点， 也只有一个出度为零的点， 称作汇点。在AOE-网中， 一条路径各弧上的权值之和称为该路径的**带权路径长度**（后面简称路径长度）。要估算整项工程完成的最短时间，就是要找一条从源点到汇点的带权路径长度最长的路径， 称为**关键路径**。关键路径上的活动叫做**关键活动**，这些活动是影响工程进度的关键， 它们的提前或拖延将使整个工程提前或拖延。

1. 事件 v~i~ 的最早发生时间 ve(i)：从源点到 v~i~ 的最长路径长度。
2. 事件 v~i~ 的最迟发生时间 vl(i)：v~i~ 的最迟发生时间不得迟于其后继事件 v~k~ 的最迟发生时间减去活动 <v~i~, v~k~> 的持续时间。
3. 活动 a~i~ = <v~j~, v~k~> 的最早开始时间 e(i)：只有事件 v~j~ 发生了，活动 a~i~ 才能开始。所以， 活动 a~i~ 的最早开始时间等于事件 v~j~ 的最早发生时间 ve(j)，即：e(i) = ve(j)
4. 活动 a~i~ = <v~j~, v~k~> 的最晚开始时间 l(i)：活动a~i~的开始时间需保证不延误事件V~k~ 的最迟发生时间。所以活动a~i~ 的最晚开始时间l(i)等于事件V~k~ 的最迟发生时间vl(k**)**减去活动a~i~ 的持续时间W~j,k~, 即：l(i) = vl(k) - w~j,k~



**关键路径求解过程：**

1. 对图中顶点进行排序，在排序过程中按拓扑序列求出每个事件的最早发生时间 ve(i)。
2. 按逆拓扑序列求出每个事件的最迟发生时间 vl(i)。
3. 求出每个活动 a~i~ 的最早开始时间 e(i)。
4. 求出每个活动 a~i~ 的最晚开始时间 l(i)。
5. 找出 e(i) = l(i) 的活动 a~i~，即为关键活动。由关键活动形成的由源点到汇点的每一条路径就是关键路径，关键路径有可能不止一条。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230408153943827.png" alt="image-20230408153943827" style="zoom:67%;" />





# 查找

## 查找的基本概念

**查找表：**是由同一类型的数据元素（或记录）构成的集合。

**关键字：**是数据元素（或记录）中某个数据项的值，用它可以标识一个数据元素（或记录）。若此关键字 可以唯一地标识一个记录，则称此关键字为主关键字（对不同的记录，其主关键字均不同）。反之，称用以识别若干记录的关键字为次关键字。当数据元素只有一个数据项时，其关键字即为该数据元素的值。

**查找：**是指根据给定的某个值，在查找表中确定一个其关键字等于给定值的记录或数据元素。

**动态查找表和静态查找表：**在查找的同时对表做修改操作（如插入和删除），则相应的表称之为动态查找表，否则称之为静态查找表。

**平均查找长度：**为确定记录在查找表中的位置，需和给定值进行比较的关键字个数的期望值。对于含有 n 个记录的表，查找成功的平均查找长度为： ASL = $\sum \limits ^n_{i=1} P_iC_i$，其中 P~i~ 为查找表中第 i 个记录的概率，且 $\sum \limits ^n_{i=1} P_i$ = 1；C~i~ 为找到表中其关键字与给定值相等的第 i 个记录时，和给定值已进行过比较的关键字个数。





## 线性表的查找

### 顺序查找

查找过程为：从表的一端开始，依次将记录的关键字和给定值进行比较，若某个记录的关键字和给定值相等，则查找成功；反之，若扫描整个表后，仍未找到关键字和给定值相等的记录，则查找失败。



### 折半查找

也称**二分查找**，要求线性表采用顺序存储结构，且表中元素按照关键字有序排列。

查找过程为：从表的中间记录开始， 如果给定值和 中间记录的关键字相等， 则查找成功；如果给定值大于或者小于中间记录的关键字， 则在表中大于或小与中间记录的那一半中查找，这样重复操作， 直到查找成功，或者在某一步中查找区间为空**， **则代表查找失败。

折半查找过程可用二叉树来描述。树中每一结点对应表中一个记录，但结点值 不是记录的关键字 ，而是记录在表中的位置序号 。把当前查找区间的中间位置作为根， 左子表和右子表分别作为根的左子树和右子树，由此得到的二叉树称为折半查找的**判定树**。

折半查找的时间复杂度为 O(log~2~^n^)，比较次数少，效率高，但是对表结构要求高，且查找前需要排序，耗时。



### 分块查找

**索引顺序查找**：性能在上述两个算法之间。除表本身外，还需要建立一个“索引表”。

如下面一个有 18 条记录的表，可分为3个子表，1-6,7-12,13-18，对每个子表（或称块）建立一个索引项，其中包括两项内容：关键字项**（**其值为该子表内的最大关键字**） **和指针项（指示该子表的第一个记录在表中位置）。索引表按关键字有序**，**则表或者有序或者 分块有序。所谓 “分块有序”指的是第二个子表中所有记录的关键字均大于第一个子表中的最大关键字，第三个子表中的所有关键字均大于第二个子表中的最大关键字，……，依次类推。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230408160553816.png" alt="image-20230408160553816" style="zoom:67%;" />

查找过程：先确定待查记录所在的块（子表），然后在块中顺序查找。

设表长 n，每个块中记录数 s，当 s 取 $\sqrt{n}$ 时，分块查找的平均查找长度是 $\sqrt{n} + 1$





## 树表的查找

### 二叉排序树

**二叉排序树（二叉查找树）：**或者是一颗空树，或者是具有下面性质的二叉树：

- 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值。
- 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值。
- 它的左、右子树也分别为二叉排序树。

由定义知：中序遍历一棵二叉树时可以得到一个结点值递增的有序序列。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230408162539451.png" alt="image-20230408162539451" style="zoom:67%;" />

**二叉排序树的递归查找：**

1. 若二叉排序树为空，则查找失败，返回空指针。
2. 若二叉排序树非空，将给定值 key 与根节点的关键字 root 进行比较：
	- 若 key 等于 root，则查找成功，返回根节点地址；
	- 若 key 小于 root，则递归查找左子树。
	- 若key 大于 root，则递归查找右子树。

**二叉排序树的插入：**

1. 若二叉排序树为空，则待插入结点作为根节点插入到空树中。
2. 若二叉排序树非空，则将 key 与根结点的关键字 root 进行比较：
	- 若 key 小于 root，则将该结点插入左子树。
	- 若 key 大于 root，则将该结点插入右子树。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230408163351704.png" alt="image-20230408163351704" style="zoom:67%;" />

**二叉排序树的删除：**

首先从根节点开始查找关键字为 key 的待删结点，如果不存在此结点，不做任何操作；否则，：

1. 若待删结点为叶子结点，则它的左右子树均为空，删去该结点不改变树结构，所以直接删去即可，即将双亲结点指向孩子结点的指针置 null。
2. 若待删结点只有左右子树之一，只需要让左右子树直接成为双亲结点的左子树即可。
3. 若左右子树均不为空，从下图(b) 可知，在删去待删结点之前，中序遍历得到的序列为{…C~L~C…Q~L~QS~L~SPP~R~F…}，在删去待删结点之后，为保持其他元素之间的先对位置不变，有两种处理方式：
	1. 令带删结点的左子树为双亲结点的左子树，而右子树称为 *S 的右子树
	2. 令带删结点的直接前驱或直接后继代替该结点，然后再从二叉排序树中删去它的直接前驱或直接后继。当以直接前驱\*s替代\*p时， 由千\*s只有左子树 **, **则在删去\*s之后， 只要令其左子树称为*p的双亲结点的右子树即可。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230408171401760.png" alt="image-20230408171401760" style="zoom:67%;" />

二叉排序树删除的三种情况：

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230408171535463.png" alt="image-20230408171535463" style="zoom:67%;" />



### 平衡二叉树

**平衡二叉树（AVL树）：**空树，或是有下面性质的二叉排序树：

- 左子树和右子树的深度之差的绝对值不超过1。
- 左子树和右子树也是平衡二叉树。

**平衡因子：**该结点左子树和右子树的深度之差，平衡二叉树上的取值只能有 -1、0、1。只要二叉树上有一个结点的平衡因子的绝对值大于1, 则该二叉树就是不平衡的。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230408201633085.png" alt="image-20230408201633085" style="zoom:67%;" />

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230408201642737.png" alt="image-20230408201642737" style="zoom:67%;" />

因为AVL树上任何结点的左右子树的深度之差都不超过1， 则可以证明它的深度和log~2~^n^是同数量级的（其中n为结点个数）。 由此，其查找的时间复杂度是O(log~2~^n^)



创建平衡二叉树：先按照二叉排序树处理，当平衡二叉树的特性被破坏之后，进行调整：找到离插入结点最近且平衡因子绝对值超过1的祖先结点， 以该结点为根的子树称为**最小不平衡子树**， 可将重新平衡的范围局限于这棵子树。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230408202055993.png" alt="image-20230408202055993" style="zoom:67%;" />

一般情况下，假设最小不平衡子树的根结点为 **A,** 则失去平衡后进行调整的规律可归纳为下列4种情况：

1. LL 型：由于在 A 左子树根结点的左子树上插入结点，A的平衡因子由 1 增至 2, 致使以A为根的子树失去平衡，则需进行一次向右的顺时针旋转操作。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230408202345044.png" alt="image-20230408202345044" style="zoom:67%;" />

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230408202358137.png" alt="image-20230408202358137" style="zoom:67%;" />

2. RR 型：由于在 A 的右子树根结点的右子树上插入结点， A 的平衡因子由-1 变为-2,致使以 A 为根结点的子树失去平衡，则需进行一次向左的逆时针旋转操作。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230408202558448.png" alt="image-20230408202558448" style="zoom:67%;" />

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230408202610360.png" alt="image-20230408202610360" style="zoom:67%;" />

3. LR型：由于在A的左子树根结点的右子树上插入结点， A的平衡因子由1增至2,致使以A为根结点的子树失去平衡， 则需进行两次旋转操作。 第一次对B及其右子树进行逆时针旋转， C转上去成为B的根， 这时变成了LL型， 所以第二次进行LL型的顺时针旋转即可恢复平衡。 如果C原来有左子树， 则调整C的左子树为B的右子树。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230408202831860.png" alt="image-20230408202831860" style="zoom:67%;" />

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230408202847827.png" alt="image-20230408202847827" style="zoom:67%;" />

4. RL 型：由于在 A 的右子树根结点的左子树上插入结点**，** A 的平衡因子由-1变为-2,致使以A 为根结点的子树失去平衡， 则旋转方法和 LR 型相对称，也需进行两次旋转， 先顺时针右旋， 再逆时针左旋。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230408203029677.png" alt="image-20230408203029677" style="zoom:80%;" />

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230408203042822.png" alt="image-20230408203042822" style="zoom:67%;" />

**平衡二叉树的插入：**

在平衡的二叉排序树BBST上插入一个新的数据元素e

1. 若BBST为空树，则插入一****个数据元素为**e**的新结点作为BBST的根结点，树的深度增1。
2. 若e的关键字和BBST的根结点的关键字相等，则不进行插入。
3. 若e的关键字小于BBST的根结点的关键字，而且在BBST的左子树中不存在和e有相同关键字的结点，则将e插入在BBST的左子树上**，**并且当插入之后的左子树深度增加**(**+I)时，分别就下列不同情况处理之：
	- BBST 的根结点的平衡因子为-1 (右子树的深度大于左子树的深度**）：**则将根结点的平衡因子更改为0, BBST的深度不变；
	- BBST的根结点的平衡因子为0(左、右子树的深度相等）：则将根结点的平衡因子更改为1, BBST的深度增 1。
	- BBST的根结点的平衡因子为1 (左子树的深度大于右子树的深度）：若BBST的左子树根结点的平衡因子为 1 ，则需进行单向右旋平衡处理**，**并且在右旋处理之后**，**将根结点和其右子树根结点的平衡因子更改为 0, 树的深度不变；
	- 若BBST的左子树根结点的平衡因子为-1 则需进行先向左、后向右的双向旋转平衡处理，并且在旋转处理之后。修改根结点和其左、右子树根结点的平衡因子，树的深度不变。
4. 若e的关键字大于BBST的根结点的关键字，而且在BBST的右子树中不存在和e有相同关键字的结点，则将e插入在BBST的右子树上，并且当插入之后的右子树深度增加(+I)时，分别就不同情况处理之。处理情况同上。





### B-树

前面的都是内查找法，以结点为单位查找，适用于存储在计算机内存中较小的文件，当文件很大且存放在外存中时就不适用了。

B-树用于外查找的平衡多叉树，磁盘管理系统中的目录管理，数据库系统中的索引组织大多采用这种数据结构。

**B-树：**一颗 m 阶的 B-树，或为空树，或满足下面的性质的 m 叉树：

1. 树中每个结点至多有 m 棵子树。
2. 若根结点不是叶子结点，则至少有两棵树。
3. 除根之外的所有非终端结点至少有 $\lceil m/2 \rceil$棵子树。
4. 所有的叶子结点都出现在同一层次中，并且不带信息，通常称为失败结点（失败结点并不存在，指向这些结点的指针为空。引入失败结点是为了便于分析 B-树的查找性能）。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230408205259921.png" alt="image-20230408205259921" style="zoom:67%;" />

其中， K~i~（i = 1, …, n）为关键字，且 K~i~ < K~i+1~ （i = 1,…,n - 1）;P~i~（i = 1, …, n）为指向子树根结点的指针，且指针 P~i-1~ 所指子树中所有节点的关键字均小于 K~i~（i = 1, …, n），P~n~ 所指子树中所有结点的关键字均大于 K~n~，n($\lceil m/2 \rceil - 1 \leq n \leq m - 1$) 为关键字的个数（或 n+1 为子树个数）。

从上述定义可以看出，对任一关键字 K~i~ 而言，P~i-1~ 相当于指向其 “ 左子树"， P~i~ 相当于指向其 “右子树” 。

B-树具有平衡、有序、多路的特点。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230408205931760.png" alt="image-20230408205931760" style="zoom:67%;" />

1. 所有叶子结点均在同一层次，这体现出其平衡的特点。
2. 树中每个结点中的关键字都是有序的，且关键字K~i~ "左子树” 中的关键字均小于K~i~ , 而其 “右子树” 中的关键字均大于K~i~, 这体现出其有序的特点。
3. 除叶子结点外，有的结点中有一个关键字，两棵子树，有的结点中有两个关键字，三棵子树，这种4阶的B-树最多有三个关键字，四棵子树，这体现出其多路的特点。
4. 在具体实现时，为记录其双亲结点，B-树结点的存储结构通常增加一个parent指针，指向其双亲结点。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230408210146478.png" alt="image-20230408210146478" style="zoom:67%;" />



**B-树的查找：**相当于二叉排序树的查找方式，直到找到叶子结点还没找到说明不存在。

在含有 N个关键字的 B-树上进行查找时，从根结点到关键字所在结点的路径上涉及的结点数不超过 $log _{\lceil m/2 \rceil}(\frac{N + 1}{2}) + 1$.



**B-树的插入：**B-树是动态查找树， 因此其生成过程是从空树起，在查找的过程中通过逐个插入关键字而得到。但由千B-树中除根之外的所有非终端结点中的关键字个数必须大于等于$\lceil m/2 \rceil - 1$, 因此，每次插入一个关键字不是在树中添加一个叶子结点，而是首先在最低层的某个非终端结点中添加一个关键字，若该结点的关键字个数不超过m-1, 则插入完成，否则表明结点已满，要产生结点的 “分裂＂，将此结点在 同一层分成两个结点。一般情况下，结点分裂方法是：以中间关键字为界把结点一分为二，成为两个结点，并把中间关键字向上插入到双亲结点上，若双亲结点巳满，则采用同样的方法继续分解。最坏的情况下，一直分解到树根结点，这时B-树高度增加1。

下面为依次插入 30、 26、 85、 7的过程：

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230408211622826.png" alt="image-20230408211622826" style="zoom: 67%;" />

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230408211642545.png" alt="image-20230408211642545" style="zoom: 67%;" />

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230408211707921.png" alt="image-20230408211707921" style="zoom:67%;" />



**B-树的删除：**在B-树的某个结点中删除指定的关键字及其邻近的一个指针， 删除后应该进行调整使该树仍然满足B-树的定义，也就是要保证每个结点的关键字数目范围为$[\lceil m/2 \rceil - 1, m]$。删除记录后，结点的关键字个数如果小于$\lceil m/2 \rceil - 1$, 则要进行 “ 合并”结点的操作。除了删除记录，还要删除该记录邻近的指针。若该结点为最下层的非终端结点， 由于其指针均为空， 删除后不会影响其他结点，可直接删除；若该结点不是最下层的非终端结点，邻近的指针则指向一棵子树，不可直接删除。此时可做如下处理：将要删除记录用其右（左）边邻近指针指向的子树中关键字最小（大）的记录（该记录必定在最下层的非终端结点中）替换。采取这种方法进行处理， 无论要删除的记录所在的结点是否为最下层的非终端结点， 都可归结为在最下层的非终端结点中删除记录的情况。



<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230408213342112.png" alt="image-20230408213342112" style="zoom:67%;" />

删除最下层非终端结点中的关键字：

1. 被删关键字所在结点中的关键字数目不小于$\lceil m/2 \rceil$，则只需从该结点中删去该关键字 K~i~和相应指针P~i~ , 树的其他部分不变。如下面(a)中删去上图的12。
2. 被删关键字所在结点中的关键字数目等于$\lceil m/2 \rceil - 1$，而与该结点相邻的右兄弟（或左兄弟）结点中的关键字数目大于$\lceil m/2 \rceil - 1$, 则需将其兄弟结点中的最小（或最大）的关键字上移至双亲结点中，而将双亲结点中小于（或大于）且紧靠该上移关键字的关键字下移至被删关键字所在结点中。如(b)中删除50。
3. 被删关键字所在结点和其相邻的兄弟结点中的关键字数目均等于$\lceil m/2 \rceil - 1$。假设该结点有右兄弟， 且其右兄弟结点地址由双亲结点中的指针p~i~ 所指，则在删去关键字之后， 它所在结点中剩余的关键字和指针，加上双亲结点中的关键字K~i~一起， 合并到p~i~ 所指兄弟结点中（若没有右兄弟， 则合并至左兄弟结点中)，如(c)中删去53。(d) 是(c)中删去37。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230408214044429.png" alt="image-20230408214044429" style="zoom:67%;" />





### B+树

一种 B- 树的变形树，更适合用于文件索引系统。

**B+树和B-树的差异：**

1. 有n棵子树的结点中含有n个关键字；
2. 所有的叶子结点中包含了全部关键字的信息，以及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接；
3. 所有的非终端结点可以看成是索引部分，结点中仅含有其子树（根结点）中的最大（或最小）关键字。

通常在B+树上有两个头指针，一个指向根结点，另一个指向关键字最小的叶子结点。因此，可以对 B+树进行两种查找运算： 一种是从最小关键字起顺序查找，另一种是从根结点开始，进行随机查找。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230408214505606.png" alt="image-20230408214505606" style="zoom:67%;" />

在B+树上进行随机查找、插入和删除的过程基本上与B-树类似。

**查找：**若非终端结点上的关键字等于给定值， 并不终止，而是继续向下直到叶子结点。因此，在B+树中，不管查找成功与否，每次查找都是走了一条从根到叶子结点的路径。

B+树不仅能够有效地查找单个关键字，而且更适合查找某个范围内的所有关键字。处理方式：通过一次查找找出关键字 a, 不管它是否存在，都可以到达可能出现a的叶子结点，然后在叶子结点中查找关键字值等于a或大于a的那些关键字，对于所找到的每个关键字都有一个指针指向相应的记录，这些记录的关键字在所需要的范围。 如果在当前结点中没有发现大于b的关键字，就可以使用当前叶子结点的最后一个指针找到下一个叶子结点，并继续进行同样的处理，直至在某个叶子结点中找到大于b的关键字，才停止查找。

**插入：**仅在叶子结点上进行插入，当结点中的关键字个数大于m时要分裂成两个结点，它们所含关键字的个数分别为$$\lfloor \frac{m+1}{2} \rfloor$$和$\lceil \frac{m+1}{2} \rceil$；并且，它们的双亲结点中应同时包含这两个结点中的最大关键字。

**删除：**B+树的删除也仅在叶子结点进行，当叶子结点中最大关键字被删除时，其在非终端结点中的值可以作为一个 “分界关键字” 存在。若因删除 而使结点中关键字的个数少于$\lceil m/2 \rceil$时，其和兄弟结点的合并过程亦和B-树类似。





## 散列表的查找

### 相关术语

基于线性表、树表的查找方法都是比较关键字之间的相对大小，记录在存储结构的位置和其关键字无直接关系，其查找时间与表的长度有关。当结点个数很多时需要和大量无效结点比较，致使查找速度慢。

**散列表查找法（又叫杂凑法、散列法）：**通过对元素的关键字值进行某种运算，直接求出元素的地址，即使用关键字到地址的直接转换方法，而不需要反复比较。

**散列函数和散列地址：**在记录的存储位置 p 和其关键字 key 之间建立一个确定的对应关系 H，使 p = H(key)，称这个对应关系 H 为散列函数， p 为散列地址。

**散列表：**一个有限连续的地址空间，用以存储按散列函数计算得到相应散列地址的数据记录。通常散列表的存储空间是一个一维数组，散列地址是数组的下标。

**冲突和同义词：**对不同的关键字可能得到同一散列地址，即 key~1~ $\neq$ key~2~，而 H(key~1~) = H(key~2~)，这种现象叫做冲突。具有相同函数值的关键字对该散列函数来说称作同义词，key~1~ 与 key~2~ 互称为同义词。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230409101454695.png" alt="image-20230409101454695" style="zoom:67%;" />

在实际应用中，理想化的、不存在冲突的散列表极少存在，因为散列表中关键字的取值集合远远大于表空间的地址集。



### 散列函数的构造方法

通常考虑散列表的长度、关键字的长度、关键字的分布情况、计算散列函数所需时间、记录的查找频率。

“好”的散列函数应遵循的原则：

- 函数计算要简单，每一关键字只能有一个散列地址与之对应。
- 函数的值域须在表长的范围内，计算出的散列地址的分布应均匀，尽可能减少冲突。



#### 数字分析法

如果事先知道关键字集合， 且每个关键字的位数比散列表的地址码位数多，每个关键字由n位数组成，如 K~1~K~2~…K~n~ , 则可以从关键字中提取数字分布比较均匀的若干位作为散列地址。

如80个8位十进制的记录，可以取每个记录的第4、5位作为散列表的记录：

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230409102211652.png" alt="image-20230409102211652" style="zoom:67%;" />

适用情况：事先必须明确知道所有的关键字每一位上各种数字的分布情况。



#### 平方取中法

在选定散列函数时不确定关键字的所有情况，而一个数平方后的中间几位数和数的每一位都相关，如果取关键字平方后的中间几位或其组合作为散列地址，则使随机分布的关键字得到的散列地址也是随机的，具体所取的位数由表长决定。

适用情况：不能事先了解关键字的所有情况，或难以直接从关键字中找到取值较分散的几位。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230409102733876.png" alt="image-20230409102733876" style="zoom:67%;" />



#### 折叠法

将关键字分割成位数相同的几部分（最后一部分的位数可以不同），然后取这几部分的叠加和（舍去进位） 作为散列地址，这种方法称为折叠法。根据数位叠加的方式，可以把折叠法分为移位叠加和边界叠加两种**。**移位叠加是将分割后每一部分的最低位对齐**，**然后相加；边界叠加是将两个相邻的部分沿边界来回折叠，然后对齐相加

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230409103021647.png" alt="image-20230409103021647" style="zoom:67%;" />

适用情况：适合于散列地址的位数较少，而关键字的位数较多，且难以直接从关键字中找到取值较分散的几位。



#### 除留余数法

假设散列表表长为m, 选择一个不大于m的数p,用p去除关键字，除后所得余数为散列地址，即： H(key) = key % p

方法关键是：选取合适的 p，一般可以选 p 为小于表厂的最大质数。

该方法还可以用于上述几个方法之后取模，保证散列地址一定落在散列表的地址空间中。



### 处理冲突的方法

处理冲突的方法与散列表本身的组织形式有关。按组织形式的不同，通常分两大类：开放地址法和链地址法。



#### 开放地址法

基本思想是：把记录都存储在散列表数组中，当某一记录关键字 key的初始散列地址H~0~ = H(key) 发生冲突时**，**以H~0~ 为基础，采取合适方法计算得到另一个地址H~1~，如果H~1~ 仍然发生冲突，以 H~1~ 基础再求下一个地址 H~2~，若 H~2~ 仍然冲突，再求得H~3~。依次类推，直至H~k~不发生冲突为止，则 H~k~ 为该记录在表中的散列地址。

这种方法在寻找“下一个”空的散列地址时，原来的数组空间对所有的元素都是开放的，所以称为开放地址法。通常把寻找“下一个”空位的过程叫做**探测**。该思想用公式表示为：

H~i~ = ( H(key) + d~i~ ) % m   i = 1, 2, …, k ($k\leqslant m -1 $)

其中，H(key)为散列函数，m为散列表表长，d~i~ 为增量序列。根据d~i~ 取值的不同，可以分为以下3种探测方法：

1. **线性探测法：**将散列表假想成一个循环表，发生冲突时**，**从冲突地址的下一单元顺序寻找空单元，如果到最后一个位置也没找到空单元，则回到表头开始继续查找，直到找到一个空位，就把此元素放入此空位中。如果找不到空位，则说明散列表已满，需要进行溢出处理。  d~i~ = 1, 2,  …, m - 1
2. **二次探测法：** d~i~ = 1^2^, -1^2^, 2^2^, -2^2^, …, +k^2^,  -k^2^ ( $k \leqslant m/2$ )
3. **伪随机探测法：** d~i~ = 伪随机数序列

下图中，对(a)假设5号位置有冲突，则处理冲突如下，(c)中假设伪随机数为9：

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230409105623415.png" alt="image-20230409105623415" style="zoom:67%;" />

从上述线性探测法处理的过程中可以看到一个现象：当表中 i, i+ 1, i+2 位置上已填有记录时，下一个散列地址为i、i+ 1 、i+2 和 i + 3 的记录都将填 i + 3 的位置，这种在处理冲突过程中发生的两个第一个散列地址不同的记录争夺同一个后继散列地址的现象称作“二次聚集” （或称作“堆积”），即在处理同义词的冲突过程中又添加了非同义词的冲突。

**三种方法的优缺点**：

1. 线性探测法：只要散列表未满就总能找到一个不冲突的地址，但会产生“二次聚集”现象。
2. 二次探测法和伪随机探测法：可以避免“二次聚集”现象，但不能保证一定能找到不冲突的地址。



#### 链地址法

基本思想是：把具有相同散列地址的记录放在同一个单链表中，称为同义词链表。有 m 个散列地址就有 m 个单链表**，**同时用数组 HT[0,…, m-1]存放各个链表的头指针，凡是散列地址为 i 的记录都以结点方式插入到以 HT[i] 为头结点的单链表中。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230409110810610.png" alt="image-20230409110810610" style="zoom:67%;" />



### 散列表的查找

算法步骤：

1. 给定待查找的关键字 key，根据造表时设定的散列函数计算 H~0~ = H(key)
2. 若单元 H~0~ 为空，则所查元素不存在。
3. 若单元 H~0~ 中元素的关键字为 key， 则查找成功。
4. 否则重复下述解决冲突的过程：
	- 按处理冲突的方法，计算下一个散列地址 H~i~
	- 若单元 H~i~ 为空，则所查元素不存在
	- 若单元 H~i~ 中元素的关键字为 key，则查找成功

散列表的**装填因子**$\alpha$ 定义为： $\alpha = \frac{表中填入的记录数}{散列表的长度}$，其标志散列表的装满程度。直观地看，$\alpha$越小，发生冲突的可能性就越小；反之，$\alpha$越大，表中已填入的记录越多，再填记录时，发生冲突的可能性就越大，则查找时，给定值需与之进行比较的关键字的个数也就越多。

散列函数的 “好坏”首先影响出现冲突的频繁程度。但一般情况下认为：凡是＂均匀的＂散列函数**，**对同一组随机的关键字，产生冲突的可能性相同，假如所设定的散列函数是＂均匀"的，则影响平均查找长度的因素只有两个—一处理冲突的方法和装填因子 。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230409130501946.png" alt="image-20230409130501946" style="zoom:67%;" />

散列表的平均查找长度是$\alpha$的函数，而不是记录个数n的函数，所以不论 n 多大，都可以选择合适的 $\alpha$ 将平均查找长度限定在一个范围。

查找失败的情况：

1. 单元为空
2. 按处理冲突的方法探测一遍后仍未找到



<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230409130951032.png" alt="image-20230409130951032" style="zoom:67%;" />

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230409131038935.png" alt="image-20230409131038935" style="zoom:67%;" />

二叉排序树在形态均匀时性能最好，而形态为单支树时其查找性能则退化为与顺序查找相同，因此，二叉排序树最好是一棵平衡二叉树。 



<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230409131050305.png" alt="image-20230409131050305" style="zoom:67%;" />





# 排序

## 概述

### 基本概念

**排序：**是按关键字的非递减或非递增顺序对一组记录重新进行排列的操作。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230409131444562.png" alt="image-20230409131444562" style="zoom: 67%;" />



**排序的稳定性：**假设 K~i~ = K~j~ ($1 \leq i \leq n,1 \leq j \leq n, i \neq j$​)，且在排序前的序列中 R~i~ 领先于 R~j~（i < j）。若在排序后的序列中R~i~仍领先于R~j~，则称所用的排序方法是稳定的；反之， 若可能使排序后的序列中 R~j~ 领先于 R~i~, 则称所用的排序方法是不稳定的。



**内部排序：**待排序记录全部存放在计算机内存中进行排序的过程；

**外部排序：**是待排序记录的数量很大，以致内存一次不能容纳全部记录， 在排序过程中尚需对外存进行访问的排序过程。



### 内部排序方法的分类

将排序记录区分为两个区域：有序序列区和无序序列区：

1. 插入类：将无序子序列中的一个或几个记录 ＂插入” 到有序序列中， 从而增加记录的有序子序列的长度。 主要包括直接插入排序、折半插入排序和希尔排序。
2. 交换类：通过 “交换” 无序序列中的记录从而得到其中关键字最小或最大的记录，并将它加入到有序子序列中，以此方法增加记录的有序子序列的长度。主要包括冒泡排序和快速排序。
3. 选择类：从记录的无序子序列中 “选择” 关键字最小或最大的记录，并将它加入到有序子序列中， 以此方法增加记录的有序子序列的长度。 主要包括简单选择排序、树形选择排序和堆排序。
4. 归并类：通过 “归并” 两个或两个以上的记录有序子序列， 逐步增加记录有序序列的长度。2-路归并排序是最为常见的归并排序方法。
5. 分配类：是唯一一类不需要进行关键字之间比较的排序方法， 排序时主要利用分配和收集两种基本操作来完成。基数排序是主要的分配类排序方法。





## 插入排序

基本思想是：每一趟将一个待排序的记录，按其关键字的大小插入到已经排好序的一组记录的适当位置上，直到所有待排序记录全部插入为止。



### 直接插入排序

算法步骤：

1. 设待排序的记录存放在数组 r[1…n] 中，r[1] 是一个有序序列。
2. 循环 n-1 次，每次使用顺序查找法，查找 r[i] (i = 2, …, n) 在已排好序的序列 r[1…i-1] 中插入位置，然后将 r[i] 插入表长为 i-1 的有序序列 r[1…i-1] ，直到将 r[n] 插入表长为n-1 的有序序列  r[1…n-1]，最后得到一个表长为 n 的有序序列。 

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230409133450710.png" alt="image-20230409133450710" style="zoom:67%;" />

时间复杂度O(n^2^), 空间复杂度O(1)

算法特点：

1. 稳定排序
2. 算法简便，且容易实现
3. 也适用于链式存储结构，只是在单链表上无需移动记录，只需修改相应的指针
4. 更适合初始记录基本有序的情况，当初始记录无序，n 较大时时间复杂度较高



### 折半插入排序

算法步骤：

1. 设待排序的记录存放在数组 r[1…n] 中，r[1] 是一个有序序列。
2. 循环 n-1 次，每次使用折半查找法，查找 r[i]\(i = 2, … , n) 在已排好序的序列 r[1, …, i - 1] 中插入位置，然后将 r[i] 插入表长为 i- 1 的有序序列r[1, …, i - 1] ，直到将 r[n] 插入表长为 n-1 的有序序列 r[1, …, n- 1] ，最后得到一个表长为 n 的有序序列。

在平均情况下，折半插入排序 仅减少了关键字间的比较次数，而记录的移动次数不变。因此，折半插入排序的时间复杂度仍为O(n^2^)，空间复杂度O(1)

算法特点：

1. 稳定排序
2. 因为进行折半查找，所以需要顺序结构存储，不能用于链式存储
3. 适合初始记录无序， n  较大时的情况



### 希尔排序

又称“缩小增量排序”

直接插入排序，当待排序的记录个数较少且待排序序列的关键字基本有序时，效率较高。希尔排序基于以上两点，从 “减少记录个数”和“序列基本有序” 两个方面对直接插入排序进行了改进。

采用分组插入的方法。先将整个待排序记录序列分割成几组，从而减少参与直接插入排序的数据量，对每组分别进行直接插入排序，然后增加每组的数据量，重新分组。 这样当经过几次分组排序后**，**整个序列中的记录“基本有序” 时，再对全体记录进行一次直接插入排序。

希尔对记录的分组，不是简单地 “逐段分割”， 而是将相隔某个“增量”的记录分成一组**。**

1. 第一趟取增量 d1 (d1<n) 把全部记录分成 d1 个组，所有间隔为 d1 的记录分在同一组，在各个组中进行直接插入排序。
2. 第二趟取增量 d2 (d2 < d1)，重复上述的分组和排序。
3. 依次类推，直到所取的增量 d~t~ = 1(d~t~ < d~t-1~ < … < d~2~ < d~1~)，所有记录在同一组中进行直接插入排序为止。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230409143200535.png" alt="image-20230409143200535" style="zoom:67%;" />

1.  第一趟取增量 d1 =5 , 所有间隔为 5 的记录分在同一组，全部记录分成 5 组， 在各个组中分别进行直接插入排序。
2.  第二趟取增量 d2 =3 , 所有间隔为 3 的记录分在同一组，全部记录分成 3 组， 在各个组中分别进行直接插入排序。
3. 第三趟取增量 d3 = 1, 对整个序列进行一趟直接插入排序**， **排序完成。

时间复杂度不确定，随 n 的变化而变化：有人指出，当增量序列为 dt[k]=2^t-k+1^时，希尔排序的时间复杂度为 O(n^3/2^), 其中 t 为排序趟数，$1 \leq k \leq \lfloor log_2^{(n+1)} \rfloor $ 。还有人在大量的实验基础上推出：当 n 在某个特定范围内，希尔排序所需的比较和移动次数约为 n^1.3^，当 n -> ∞ 时，可减少到 n( log~2~^n^ )^2^，空间复杂度O(1)。

算法特点：

1. 记录跳跃式地移动导致排序方法是不稳定的。
2. 只能用于顺序结构，不能用于链式结构。
3. 增量序列可以有各种取法，但应该使增量序列中的值没有除 1 之外的公因子，并且最后一个增量值必须等于1。
4. 记录总的比较次数和移动次数都比直接插入排序要少，n越大时，效果越明显。所以适合初始记录无序、n较大时的情况。





## 交换排序

基本思想是：两两比较待排序记录的关键字，一旦发现两个记录不满足次序要求时则进行交换，直到整个序列全部满足要求为止。



### 冒泡排序

通过两两比较相邻记录的关键字，如果发生逆序**，**则进行交换，从而使关键字小的记录如气泡一般逐渐往上“漂浮”（左移），或者使关键字大的记录如石块一样逐渐向下 ＂坠落” （右移）。

算法步骤：

1. 设待排序的记录存放在数组r[ 1 …n]中。首先将第一个记录的关键字和第二个记录的关键字进行比较，若为逆序（即 L.r[1].key>L.r[2].key), 则交换两个记录。然后比较第二个记录和第三个记录的关键字。依次类推，直至第n-1个记录和第n个记录的关键字进行过比较为止。上述过程称作第一趟起泡排序，其结果使得关键字最大的记录被安置到最后一个记录的位置上。
2. 然后进行第二趟起泡排序，对前n-1个记录进行同样操作，其结果是使关键字次大的记录被安置到第n - 1个记录的位置上。
3. 重复上述比较和交换过程，第 i 趟是从 L.r[1]到L.r[n-i+1 ]依次 比较相邻两个记录的关键字，并在 “逆序” 时交换相邻记录，其结果是这 n-i+1个记录中关键字最大的记录被交换到第n-i+1 的位置上。直到在某一趟排序过程中没有进行过交换记录的操作，说明序列已全部达到排序要求，则完成排序。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230409144841658.png" alt="image-20230409144841658" style="zoom:67%;" />

最好情况下是初始序列为正序，最坏情况则是逆序，平均下来时间复杂度O(n^2^), 空间复杂度O(1)

算法特点：

1. 稳定排序
2. 可用于链式存储结构
3. 移动记录次数较多，算法平均时间性能比直接插入排序差。当初始记录无序， n 较大时，此算法不宜采用。





### 快速排序

由冒泡算法改进而来，冒泡每次只能消除一个逆序，如果能通过两个（不相邻）记录的一次交换，消除多个逆序， 则会大大加快排序的速度。

算法步骤：

1. 选择待排序表中的第一个记录作为枢轴，将枢轴记录暂存在 r[0] 的位置上。附设两个指针 low 和 high，初始时分别指向表的下界和上界（第一趟时，low = 1; high = L.length）
2. 从表的最右侧位置依次向左搜索，找到第一个关键字小于枢轴关键字 pivotkey 的记录，将其移到 low 处。具体操作是：当 low < high 时，若 high 所指记录的关键字大于等于 pivotkey，则向左移动指针 high（执行操作 -- high），否则将 high 所指记录移到 low 所指记录。
3. 然后再从表的最左侧位置，依次向右搜索找到第一个关键字大于 pivotkey 的记录和枢轴记录交换。具体操作是：当 low<high 时，若 low所指记录的关键字小于等于 pivotkey, 则向右移动指针 low **(**执行操作++low); 否则将 low所指记录与枢轴记录交换。
4. 重复步骤2和3， 直至 low 与 high 相等为止。此时 low 或 high 的位置即为枢轴在此趟排序中的最终位置， 原表被分成两个子表。
5. 记录的交换都是在枢轴之间发生，每次交换都要移动 3 次记录，可以先将枢轴记录暂存在 r[0] 的位置上，排序过程中只移动要与枢轴交换的记录，即只做 r[row] 或 r[high] 的单向移动，直至一趟排序结束后再将枢轴记录移至正确位置上。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230409164735298.png" alt="image-20230409164735298" style="zoom:67%;" />

由上图知整个快速排序的过程可递归进行

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230409164832920.png" alt="image-20230409164832920" style="zoom:67%;" />

理论上可以证明，平均情况下，快速排序的时间复杂度为 O(nlog~2~^n^)，最好情况下（每一趟排序后都能将记录序列均匀地分割成两个长度大致相等的子表，类似折半查找。）的空间复杂度为 O(log~2~^n^)，最坏情况下（在待排序序列已经排好序的情况下，其递归树成为单支树，每次划分只得到一个比上 一次少一个记录的子序列）的空间复杂度为 O(n)。





## 选择排序

基本思想是：每一趟从待排序的记录中选出关键字最小的记录，按顺序放在已排序的记录序列的最后，直到全部排完为止。



### 简单选择排序

算法步骤：

1. 设待排序的记录存放在数组r[l… n]中。第一趟从r[1]开始，通过n-1次比较，从n个记录中选出关键字最小的记录，记为r[k], 交换r[1]和r[k]。
2. 第二趟从r[2]开始，通过n-2次比较，从n - 1个记录中选出关键字最小的记录，记为r[k],交换r[2]和r[k] 。
3. 依次类推，第 i 趟从r[i]开始，通过n-i次比较，从n-i+1个记录中选出关键字最小的记录，记为r[k], 交换r[i]和r[k]。
4. 经过 n-1 趟，排序完成。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230409165736649.png" alt="image-20230409165736649" style="zoom:67%;" />

时间复杂度O(n^2^), 空间复杂度O(1)

算法特点：

1. 就算法本身而言，是一个稳定的算法，但是上图是不稳定的，是由于“交换记录”的策略产生的，改变这个策略后就可以写出不产生“不稳定现象”的选择排序算法。
2. 可用于链式存储结构。
3. 移动记录次数较少，当每一记录占用的空间较多时，此方法比直接插入排序快。





### 树形选择排序

对简单选择排序进行改进：减少比较的次数

又称“锦标赛排序”，是一种按照锦标赛思想进行选择排序的方法。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230409170310641.png" alt="image-20230409170310641" style="zoom:67%;" />



首先对 n 个记录的关键字进行两两比较，然后在其中 $\lceil \frac{n}{2} \rceil$个较小者之间再进行两两比较，如此重复，直至选出最小关键字的记录为止。可以用一颗有 n 个叶子结点的完全二叉树表示。

算法步骤：

1. 叶子结点是所有的关键字，非终端结点放其左右子结点中较小的关键字，根结点就是非终端节点中最小的关键字。
2. 去除这个关键字，并将这个关键字对应的叶子结点改为∞，并从该叶子结点开始，和其（或右）兄弟的关键字进行比较，修改从叶子结点到根的路径上各结点的关键字，则根结点的关键字即为次小关键字。
3. 进行重复，直到选出所有的叶子结点关键字。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230409171127259.png" alt="image-20230409171127259" style="zoom:67%;" />

时间复杂度是 O(nlog~2~^n^)，但是有辅助空间较多，和“最大值”进行多余的比较等缺点。为改进缺点，引入堆排序。





### 堆排序

一种树形选择排序，在排序过程中，将待排序的记录 r[1..n]看成是一棵完全二叉树的顺序存储结构，利用完全二叉树中双亲结点和孩子结点之间的内在关系，在当前无序的序列中选择关键字最大（或最小）的记录。

**堆：** n 个元素的序列 {K~1~, K~2~, …, K~n~} ，当且仅当满足以下条件时：

1. K~i~$\geqslant $ K~2i~且K~i~$\geqslant $ K~2i+1~ 或 K~i~$\leq $ K~2i~ 且 K~i~$\leq$ K~2i+1~ ( 1 $\leq$ i $\leq \lfloor \frac{n}{2} \rfloor$  )

若将和此序列对应的一维数组看成是 一个完全二叉树，则堆实质上是 满足如下性质的完全二叉树：树中所有非终端结点的值均不大于（或 不小于） 其左、右孩子结点的值。

堆顶元素（或 完全二叉树的根）必为序列中 n个元素的最大值（或最小值），分别称之为大根堆和小根堆。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230409174358650.png" alt="image-20230409174358650" style="zoom:67%;" />

堆排序利用了大根堆（或 小根堆） 堆顶记录的关键字最大（或最小）这 一特征，使得当前无序的序列中选择关键字最大（或最小） 的记录变得简单。

算法步骤：

1. 按堆的定义将待排序序列r[1..n]调整为大根堆（这个过程称为建初堆），交换r[1]和r[n],则r[n]为关键字最大的记录。
2. 将r[1...n-1]重新调整为堆，交换r[1]和r[n-1], 则r[n-1]为关键字次大的记录。
3. 循环n-1次，直到交换了r[1]和r[2]为止，得到了一个非递减的有序序列r[1..n]。
4. 同样可以通过构造小根堆得到一个非递增的有序序列。



**调整堆**

下图(a)是个堆，将堆顶元素97和堆中最后一个元素38交换后，如图(b)所示。由于此时除根结点外，其余结点均满足堆的性质，由此仅需自上至下进行一条路径上的结点调整即可。首先以堆顶元素38和其左、右子树根结点的值进行比较，由于左子树根结点的值大于右子树根结点的值且大于根结点的值，则将38和76交换；由于38替代了76之后破坏了左子树的“堆”，则需进行和上述相同的调整，直至叶子结点，调整后的状态如图(C)所示。重复上述过程，将堆顶元素76和堆中最后一个元素27交换且调整，得到如图(d)所示新的堆。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230409175232369.png" alt="image-20230409175232369" style="zoom:67%;" />

上述过程就像过筛子一样，把较小的关键字逐层筛下去，而将较大的关键字逐层选上来。因此**，**称此方法为“筛选法”。

算法步骤：

假设r[s+1..m]巳经是堆的情况下，按“筛选法” 将r[s. . m]调整为以r[s]为根的堆

1. 从r[2s]和r[2s+1]中选出关键字较大者，假设r[2s]的关键字较大，比较r[s]和r[2s]的关键字。
	- 若r[s].key> = r[2s].key, 说明以r[s]为根的子树已经是堆，不必做任何调整。
	- 若r[s].key<r[2s].key, 交换r[s]和r[2s]。交换后，以r[2s+1]为根的子树仍是堆，如果以r(2s]为根的子树不是堆，则重复上述过程，将以 r[2s]为根的子树调整为堆，直至进行到叶子结点为止。



**建初堆**

要将一个无序序列调整为堆，就必须将其所对应的完全二叉树中以每一结点为根的子树都调整为堆。显然， 只有一个结点的树必是堆，而在完全二叉树中，所有序号大于$\lfloor n/2 \rfloor$的结点都是叶子**，**因此以这些结点为根的子树均已是堆。这样，只需利用筛选法，从最后一个分支结点$\lfloor n/2 \rfloor$ 开始，依次将序号为 $\lfloor n/2 \rfloor$、$\lfloor n/2 \rfloor$ -1 、…、 1 的结点作为根的子树都调整为堆即可。

算法步骤：对于无序序列 r[1…n], 从i= n/2开始，反复调用筛选法HeapAdjust (L,i,n), 依次将以r[i], r[i-1], …，r[1]为根的子树调整为堆**。**

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230409180538534.png" alt="image-20230409180538534" style="zoom:67%;" />

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230409180620911.png" alt="image-20230409180620911" style="zoom: 80%;" />



堆排序的运行时间主要耗费在建初堆和调整堆时进行的反复 “筛选” 上。

堆排序在最坏的情况下，其时间复杂度为 O( nlog~2~^n^ )，平均性能接近于最坏性能，空间复杂度是 O(1)。

算法特点：

1. 是不稳定排序
2. 只能用于顺序结构，不能用于链式结构 
3. 初始建堆所需 的比较次数较多，因此 记录数较少时不宜采用。堆排序在最坏情况下时间复杂度为O(nlog~2~^n^), 相对于快速排序最坏情况下的O(n^2^ )而言是一个优点，当记录较多时较为高效





## 归并排序

**归并排序：**就是将两个或两个以上的有序表合并成一个有序表的过程。

将两个有序表合并成一个有序表的过程称为2-路归并

**归并排序算法的思想是：**假设初始序列含有n个记录，则可看成是 n个有序的子序列，每个子序列 的长度为1，然后两两归并，得到 $\lceil \frac{n}{2} \rceil $ 个长度为2 或1 的有序子序列；再两两归并，……， 如此重复，直至得到一个长度为n 的有序序列为止。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230409181428477.png" alt="image-20230409181428477" style="zoom:67%;" />

2-路归并排序中的核心操作是，将待排序序列中前后相邻的两个有序序列归并为一个有序序列。

**相邻两个有序子序列的归并：**

设两个有序表存放在同一数组中相邻的位置上： R[low .. mid]和 R[mid + l..high], 每次分别从两个表中取出一个记录进行关键字的比较，将较小者放入 T[low.. high]中，重复此过程，直至其中一个表为空 ， 最后将另一非空表中余下的部分直接复制到T中。



**归并排序**

算法步骤：2路归并排序将 R[low.. high]中的记录归并排序后放入 T[low.. high]中。 当序列长度等于 1 时，递归结束， 否则：

1. 将当前序列一分为二， 求出分裂点 mid = L(low+high)/2」;
2. 对子序列 R[low.. mid]递归，进行归并排序， 结果放入 S[low.. mid]中；
3. 对子序列 R[mid + 1..high]递归，进行归并排序， 结果放入 S[mid + 1..high]中；
4. 调用算法 Merge, 将有序的两个子序列 S[low.. mid]和 S[mid + 1..high]归并为一个有序的序列 T[low.. high]

时间复杂度O( nlog~2~^n^ )，空间复杂度 O( n )

算法特点：

1. 是稳定排序
2. 可用于链式结构，且不需要附加存储空间，但递归实现时仍需要开辟相应的递归工作栈。





## 基数排序

上述排序算法是建立在关键字比较上，而分配类排序不需要比较关键字的大小，它是根据关键字中各位的值， 通过对待排序记录进行若干趟 “ 分配 ” 与 “ 收集” 来实现排序的，是一种借助于多关键字排序的思想对单关键字排序的方法。



### 多关键字的排序

对扑克牌，每一张牌有两个 “ 关键字”：花色和面值, 且 “ 花色 ” 的地位高于 “ 面值" ,在比较任意两张牌面的大小时， 必须先比较 “ 花色"'若 “ 花色 ” 相同， 则再比较面值 。

所以有两种排序法：

**最高为优先法：**先按不同 “ 花色 ” 分成 有次序的4堆， 每一堆的牌均具有相同的 “ 花色 ” ，然后分别对每一堆按 “ 面值 ” 大小整理有序。

**最低位优先法：**这是一种 “ 分配 ” 与 “ 收集”交替进行的方法。先按不同 “ 面值＇ 分成13堆，然后将这 13堆牌自小至大叠在一起("3"在"2"之上，" 4"在"3"之上， ……， 最上面的是4张"A"), 然后将每堆按照面值的次序收集到一起 。再重新对这些牌按不同“ 花色 ” 分成 4堆， 最后将这 4堆牌按花色 的次序再收集到一起，此时同样得到一副满足如上次序关系的牌。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230410085747747.png" alt="image-20230410085747747" style="zoom:67%;" />



### 链式基数排序

类似于“最低位优先法”，内部排序法，借助“分配”与“收集”的操作。有的逻辑关键字可以看成由若干个关键字复合而成的。如一个三位数的数值可以看做（K^0^， K^1^，K^2^）组成，一个五个字母的单词可以看做（K^0^， K^1^，K^2^，K^3^，K^4^）组成，分解得到的每个关键字都在相同的范围内。

假设记录的逻辑关键字由 d 个 “关键字” 组成， 每个关键字可能取 rd 个值。只要从最低数位关键字起**， **按关键字的不同值将序列中记录 ”分配” 到 rd 个队列中后再 “收集” 之， 如此重复 d次完成排序。按这种方法实现排序称之为**基数排序**，其中 “基 ” 指的是 rd 的取值范围。

一般采用链式基数排序。

1. 首先以链表存储n个待排记录，并令 表头指针指向第一个记录。
2. 第一趟分配对最低数位关键字（个位数）进行， 改变记录的指针值将链表中的记录分配至10个链队列中去，每个队列中的记录关键字的个位数相等，其中 f[i]和 e[i]分别为第 i 个队列的头指针和尾指针；第一趟收集是改变所有非空队列的队尾记录的指针域， 令其指向下一个非空队列的队头记录， 重新将 10 个队列中的记录链成一个链表。
3. 第二趟分配是对十位数进行的，过程和个位数相同。
4. 第三趟分配是对百位数进行的，过程和个位数相同。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230410091238881.png" alt="image-20230410091238881" style="zoom:67%;" />

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230410091256588.png" alt="image-20230410091256588" style="zoom:67%;" />

时间复杂度：每一趟分配的时间复杂度为O(n), 每一趟收集的时间复杂度为O(rd), 整个排序需进行d趟分配和收集**， **所以时间复杂度为O(d(n+ rd))。

空间复杂度：所需辅助空间为2rd个队列指针，另外由于需用链表做存储结构， 还增加了n个指针域的空间， 所以空间复杂度为O(n + rd)。

算法特点：

1. 是稳定排序。
2. 可用于链式结构，也可用于顺序结构。
3. 时间复杂度可以突破基于关键字比较一类方法的下界 O( nlog~2~^n^ )，达到 O(n)。
4. 基数排序使用条件有严格的要求：需要知道各级关键字的主次关系和各级关键字的取值范围。





## 外部排序

借助外存分批调入内存完成排序。

**排序思想：**外部排序基本上由两个相对独立的阶段组成。 首先， 按可用内存大小， 将外存上含n个记录的文件分成若干长度为 L 的子文件或段 (segment), 依次读入内存并利用有效的内部排序方法对它们进行排序**， **并将排序后得到的有序子文件重新写入外存， 通常称这些有序子文件为归并段或顺串; 然后， 对这些归并段进行逐趟归并， 使归并段（有序的子文件）逐渐由小至大， 直至得到整个有序文件为止。

下图为对归并段进行排序的过程：

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230410092137613.png" alt="image-20230410092137613" style="zoom:67%;" />

上图共进行了4趟归并， 每一趟从m个归并段得到 $\lceil \frac{m}{2}\rceil$ 个归并段。 这种归并方法称为 **2-路平衡归并**。

在外部排序中实现两两归并时， 不仅要调用 merge 过程， 而且要进行外存的读／写**，**这是由于我们不可能将两个有序段及归并结果段同时存放在内存中的缘故。

假设有 10000 条记录，外存信息读写是以物理块为单位，每个物理块能容纳200条数据，则每一趟碓冰需50次读和50次写。

一般情况下：

**外部排序所需总的时间**＝内部排序（产生初始归并段）所需的时间(m*t~ls~) + 外存信息读写的时间(d * t~io~ ) + 内部归并所需的时间(S * ut~mg~ ) 

其中，t~ls~是为得到一个初始归并段进行内部排序所需时间的均值； t~io~是进行一次外存读／写时间的均值； ut~mg~是对u个记录进行内部归并所需时间； m为经过内部排序之后得到的初始归并段的个数； s为归并的趟数； d为总的读／写次数。t~io~ 取决于所用的外存设备，显然，t~io~ 较T~mg~要大得多 。因此，提高外排的效率应主要着眼于减少外存信息读写的次数d。

对同一文件而言，进行外排时所需读／写外存的次数和归并的趟数s成正比。而在一般情况下，对m个初始归并段进行k-路平衡归并时，归并的趟数为： $s = \lceil log_k^m \rceil$

因此，为减少归并趟数s，可以改进：

1. 增加归并段的个数 k
2. 减少初始归并段的个数 m

如可将上述的2-路归并改为 5-路归并，趟数减少，读写次数也减少。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230410093525121.png" alt="image-20230410093525121" style="zoom:67%;" />



“ 多路平衡归并” 的方法是通过增加归并段的个数来减少对数据的扫描趟数； ＂置换－选择＂ 的方法是在扫描一遍的前提下，能够得到更长的初始归并段，从而减少了初始归并段的个数。





### 多路平衡归并的实现

增加k可以减少s, 从而减少外存读／写的次数，但是单纯增加k将导致增加内部归并的时间ut

~mg~。如何解决矛盾？

2-路归并：令u个记录分布在两个归并段上，按merge过程进行归并。每得到归并后的一个记录，仅需一次比较即可，则得到含u个记录的归并段需进行u-1次比较。

k-路归并：令u个记录分布在K个归并段上，显然，归并后的第一个记录应是K个归并段中关键字最小的记录，即应从每个归并段的第一个记录的相互比较中选出最小者，这需要进行k-1次比较。同理，每得到归并后的有序段中的一个记录，都要进行k-1次比较。显然，为得到含u个记录的归并段需进行(u-1)(k-1) 次比较。 由此，对n个记录的文件进行外排时，在内部归并过程中进行的总的比较次数为s(k-1) (n-1)。假设所得初始归并段为m个，则可得内部归并过程中进行比较的总的次数为： $\lceil log_k^m\rceil(k-1)(n-1)t_{mg} = \lceil \frac{log_2^m}{log_2^k} \rceil(k-1)(n-1)t_{mg} $

由于 $\frac{k-1}{log_2^k}$  随k的增长而增长，则内部归并时间亦随k的增长而增长。这将抵消由于增大K而减少外存信息读写时间所得效益，这是我们所不希望的。然而，若在进行k-路归并时用**“败者树'(Tree of Loser)** , 则可使在K个记录中选出关键字最小的记录时仅需进行  $\lceil{log_2^k} \rceil$ 次比较，从而使总的归并时间由上式变为 $\lceil {log_2^m} \rceil(n-1)t_{mg}$ , 显然，这个式子和 K无关，它不再随K的增长而增长。

**败者树：**树形选择排序的一种变形。可以称图 7.8 、7.9 是胜者树(树形选择排序处)，因为每个非终端结点均表示其左、右孩子结点中的“胜者”；反之，若在双亲结点中记下刚进行完的这场比赛中的败者，而让胜者去参加更高一层的比赛，便可得到一棵“败者树”。

为防止在归并过程中某个归并段变空，可以在每个归并段中附加一个关键字为最大值的记录。当选出的 “冠军” 记录的关键字为最大值时，表明此次归并已完成。由于实现k-路归并的败者树的深度为 $\lceil log_2^k\rceil + 1$， 则在K个记录中选择最小关键字仅需进行 $\lceil log_2^k\rceil $次比较。败者树的初始化也容易实现，只要先令所有的非终端结点指向一个含最小关键字的叶子结点，然后从各个叶子结点出发调整非终端结点为新的败者即可。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230410102119567.png" alt="image-20230410102119567" style="zoom:67%;" />

K值的选择并非越大越好， 如何选择合适的K是一个需要综合考虑的问题





### 置换-选择排序

减少m是减少s的另一条途径。m是外部文件经过内部排序之后得到的初始归并段的个数， 显然， m= $\lceil \frac{n}{l}\rceil$ , 其中n为外部文件中的记录数，l为初始归并段中的记录数。

**置换选择排序:** 是在树形选择排序的基础上得来的， 它的特点是**：**在整个排序**（**得到所有初始归并段）的过程中**， **选择最小（或最大）关键字和输入、 输出交叉或平行进行。



**问题引导：**

巳知初始文件含有 24 个记录**， **它们的关键字分别为 51,49,39,46,38,29,14,61, 15,30, 1,48,52,3,63,27,4, 13,89,24,46,58,33, 76。 假设内存工作区可容纳 6 个记录， 则按选择排序可求得如下4个初始归并段：

RUNl: 29,38,39,46,49,51 

RUN2: 1,14,15,30,48,61 

RUN3: 3,4,13,27,52,63 

RUN4: 24,33,46,58,76,89 

若按置换－选择排序进行排序， 则可求得如下 3 个初始归并段：

RUNl: 29,38,39,46,49,51,61 

RUN2: 1,3,14,15,27,30,48,52,63,89 

RUN3: 4,13,24,33,46,58,76 



**操作过程：**

假设初始待排文件为输入文件FI,初始归并段文件为输出文件FO, 内存工作区为WA,FO和WA的初始状态为空， 并设内存工作区的容量可容纳w个记录

1. 从Fl输入w个记录到工作区WA。

2. 从WA中选出其中关键字取最小值的记录， 记为 MINIMAX 记录。

3. 将 MINIMAX 记录输入到FO中去。

4. 若FI不空， 则从FI输入下一个记录到WA中。

5. 从WA中所有关键字比MINIMAX记录的关键字大的记录中选出最小关键字记录，作为

	新的MINIMAX 记录。

6. 重复步骤3-5， 直至WA中选不出新的 MINIMAX 记录为止， 由此得到一个初始归并段，输出一个归并段的结束标志到FO中去。

7. 重复步骤 2-6，直到 WA 为空，由此得到所有初始归并段。

![image-20230410103521580](http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230410103521580.png)

在 WA 中选择 MINIMAX 记录的过程需要利用“败者树”来实现（细节如下）：

1. 内存工作区中的记录作为败者树的外部结点， 而败者树中根结点的双亲结点指示工作区中关键字最小的记录。
2. 为了便于选出  MINIMAX 记录，为每个记录附设一个所在归并段的序号**，**在进行关键字的比较时， 先比较段号， 段号小者为胜者；段号相同的则关键字小的为胜者。
3. 败者树的建立可从设工作区中所有记录的段号均为 “零” 开始， 然后从FI逐个输入w 个记录到工作区时，自上而下调整败者树。 由于这些记录的段号为“1” ，则它们对于“零”段的记录而言均为败者，从而逐个填充到败者树的各结点中去。

对前面例子而言的败者树：

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230410104026569.png" alt="image-20230410104026569" style="zoom:67%;" />

由置换－选择排序所得初始归并段的长度不等。且可证明， 当输入文件中记录的关键字为随机数时， 所得初始归并段的平均长度为内存工作区大小w的两倍。 

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230410104654339.png" alt="image-20230410104654339" style="zoom:67%;" />

若不计输入、输出的时间，则对n个记录的文件而言，生成所有初始归并段所需时间为O(nlog~2~^w^)。



### 最佳归并树

由置换－选择生成所得的初始归并段，其各段长度不等对平衡归并有何影呴？

**案例分析：**

假设由置换－选择 得到9个初始归并段，其长度（即记录数）依次为9, 30, 12, 18, 3, 17, 2, 6, 24。现作3-路平衡归并，则两趟归并所需对外存进行读／写次数为(9+30+ 12+ 18+3 + 17 +2+6+24)x 2x2 = 484 

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230410104930497.png" alt="image-20230410104930497" style="zoom:67%;" />

若将初始归并段的长度看成 是归并树中叶子结点的权，则此3叉树的带权路径长度的两倍恰为484 。

归并方案不同，树的带权路径长度（或外存读／写次数） 亦不同。有n个叶结点的带权路径长度最短的二叉树称哈夫曼树，存在有n个叶子结点的带权路径长度最短的3叉、4叉、…、K叉树，亦称哈夫曼树。因此，若对长度不等的m个初始归并段，构造一棵哈夫曼树作为归并树，便可使在进行外部归并时所需对外存进行读／写次数达最少。例如，对上述9个初始归并段可构造一棵下所示的归并树，按此树进行归并，仅需对外存进行446次读／写 ，这棵归并树便称做**最佳归并树**。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230410105415422.png" alt="image-20230410105415422" style="zoom:67%;" />

上图的哈夫曼树是一棵真正的3叉树，即树中只有度为3 或0 的结点。假若只有8个初始归并段，例如，在前面例子中少了一个长度为30 的归并段。如果在设计归并方案时，缺额的归并段留在最后，即除了最后一次作2-路归并外，其他各次归并仍都是3 路归并，容易看出此归并方案的外存读／写次数为386。显然，这不是最佳方案。正确的做法是，当初始归并段的数目不足时，需附加长度为零的 “虚段＂， 按照哈夫曼树构成的原则，权为零的叶子应离树根最远，因此，这个只有 8个初始归并段的归并树应如下图所示。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230410105515563.png" alt="image-20230410105515563" style="zoom:67%;" />

如何判断附加虚段的数目？

1. 当 3叉树中只有度为3或0的结点时，必有n~3~ = ( n~0~ - 1) / 2, 其中，n~3~是度为3的结点数，n~0~是度为0的结点数。由于 n~3~ 必为整数，则(n~0~ -1) mod 2=0。也就是说，对 3-路归并而言，只有当初始归并段的个数为偶数时，才需加1个虚段。
2. 在一般情况下，对k-路归并而言，容易推算得到，若(m-1) mod (k-1)=0, 则不需加虚段，否则需附加k- (m-1) mod (k-1)-1个虚段。换句话说，第一次归并为(m-1) mod (k-1)+1 -路归并。
3. 若按最佳归并树的归并方案进行磁盘归并排序，需在内存建立一张载有归并段的长度和它在磁盘上的物理位置的索引表。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230410105920447.png" alt="image-20230410105920447" style="zoom:67%;" />

**结论：**

1. 当待排序的记录个数n较小时，n^2^ 和 nlog~2~^n^  的差别不大， 可选用简单的排序方法。 而当关键字基本有序时， 可选用直接插入排序或冒泡排序，排序速度很快， 其中直接插入排序最为简单常用、性能最佳。

2. 当n较大时，应该选用先进的排序方法。对于先进的排序方法， 从平均时间性能而言，快速排序最佳，是目前基于比较的排序方法中最好的方法。但在最坏情况下，即当关键字基本有序时，快速排序的递归深度为n, 时间复杂度为O(n^2^)，空间复杂度为O(n)。堆排序和归并排序不会出现快速排序的最坏情况，但归并排序的辅助空间较大。 这样， 当n较大时， 具体选用的原则是：

  - 当关键字分布随机， 稳定性不做要求时， 可采用快速排序；
  - 当关键字基本有序， 稳定性不做要求时， 可采用堆排序；
  - 当关键字基本有序， 内存允许且要求排序稳定时， 可采用归并排序。

3. 可以将简单的排序方法和先进的排序方法结合使用。 例如， 当n较大时，可以先将待排序序列划分成若干子序列， 分别进行直接插入排序**，**然后再利用归并排序，将有序子序列合并成一个完整的有序序列。 或者， 在快速排序中， 当划分子区间的长度小于某值时， 可以转而调用直接插入排序算法。

4. 基数排序的时间复杂度也可写成 O(d·n)。因此，它最适用 n值很大而关键字较小的序列。若关键字也很大， 而序列中大多数记录的 “最高位关键字” 均不同**，**则亦可先按 “最高位关键字” 不同将序列分成若干 “小 ” 的子序列， 而后进行直接插入排序。 但基数排序使用条件有严格的要求：需要知道各级关键字的主次关系和各级关键字的取值范围， 即只适用于像整数和字符这类有明显结构特征的关键字， 当关键字的取值范围为无穷集合时，则无法使用基数排序。

5. 从方法的稳定性来比较，基数排序是稳定的内排方法， 所有时间复杂度为O(n^2^) 的简单排序法也是稳定的， 然而， 快速排序、堆排序和希尔排序等时间性能较好的排序方法都是不稳定的。

6. 一般来说， 如果排序过程中的 “比较” 是在 ”相邻的两个记录关键字**“** 间进行的，则排序方法是稳定的。 值得提出的是，稳定性是由方法本身决定的，对不稳定的排序方法而言，不管其描述形式如何，总能举出一**个**说明不稳定的实例来**。**反之**，**对稳定的排序方法，可能有的描述形式会引起不稳定，但总能找到一种不引起不稳定的描述形式。 由于大多数情况下排序是按记录的主关键字进行的**，**则所用的排序方法是否稳定无关紧要。若排序按记录的次关键字进行，则必须采用稳定的排序方法**。**





# 堆

堆实质上是一颗非终端节点的值不大于（不小于）其叶子结点值的二叉树。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230409174358650.png" alt="image-20230409174358650" style="zoom:67%;" />
